# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `net-scp` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

class Net::SCP
  include ::Net::SSH::Loggable
  include ::Net::SCP::Download
  include ::Net::SCP::Upload

  def initialize(session); end

  def download(remote, local, options = T.unsafe(nil), &progress); end
  def download!(remote, local = T.unsafe(nil), options = T.unsafe(nil), &progress); end
  def session; end
  def upload(local, remote, options = T.unsafe(nil), &progress); end
  def upload!(local, remote, options = T.unsafe(nil), &progress); end

  private

  def await_response(channel, next_state); end
  def await_response_state(channel); end
  def finish_state(channel); end
  def progress_callback(channel, name, sent, total); end
  def scp_command(mode, options); end
  def shellescape(path); end
  def start_command(mode, local, remote, options = T.unsafe(nil), &callback); end

  class << self
    def download!(host, username, remote, local = T.unsafe(nil), options = T.unsafe(nil), &progress); end
    def start(host, username, options = T.unsafe(nil)); end
    def upload!(host, username, local, remote, options = T.unsafe(nil), &progress); end
  end
end

module Net::SCP::Download
  private

  def download_start_state(channel); end
  def finish_read_state(channel); end
  def parse_directive(text); end
  def read_data_state(channel); end
  def read_directive_state(channel); end
  def read_directory(channel, directive); end
  def read_file(channel, directive); end
end

class Net::SCP::Error < ::RuntimeError; end

module Net::SCP::Upload
  private

  def next_item_state(channel); end
  def preserve_attributes_if_requested(channel); end
  def send_data_state(channel); end
  def set_current(channel, path); end
  def upload_current_state(channel); end
  def upload_directory_state(channel); end
  def upload_file_state(channel); end
  def upload_start_state(channel); end
end

Net::SCP::Upload::DEFAULT_CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

class Net::SSH::Connection::Session
  include ::Net::SSH::Loggable
  include ::Net::SSH::Connection::Constants

  def initialize(transport, options = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def busy?(include_invisible = T.unsafe(nil)); end
  def channel_open_handlers; end
  def channels; end
  def cleanup_channel(channel); end
  def close; end
  def closed?; end
  def ev_do_calculate_rw_wait(wait); end
  def ev_do_handle_events(readers, writers); end
  def ev_do_postprocess(was_events); end
  def ev_preprocess(&block); end
  def exec(command, status: T.unsafe(nil), &block); end
  def exec!(command, status: T.unsafe(nil), &block); end
  def forward; end
  def host; end
  def listen_to(io, &callback); end
  def listeners; end
  def loop(wait = T.unsafe(nil), &block); end
  def max_select_wait_time; end
  def on_global_request(type, &block); end
  def on_open_channel(type, &block); end
  def open_channel(type = T.unsafe(nil), *extra, &on_confirm); end
  def options; end
  def pending_requests; end
  def postprocess(readers, writers); end
  def preprocess(&block); end
  def process(wait = T.unsafe(nil), &block); end
  def properties; end
  def scp; end
  def send_global_request(type, *extra, &callback); end
  def send_message(message); end
  def sftp(wait = T.unsafe(nil)); end
  def shutdown!; end
  def stop_listening_to(io); end
  def transport; end

  private

  def channel_close(packet); end
  def channel_closed(channel); end
  def channel_data(packet); end
  def channel_eof(packet); end
  def channel_extended_data(packet); end
  def channel_failure(packet); end
  def channel_open(packet); end
  def channel_open_confirmation(packet); end
  def channel_open_failure(packet); end
  def channel_request(packet); end
  def channel_success(packet); end
  def channel_window_adjust(packet); end
  def dispatch_incoming_packets(raise_disconnect_errors: T.unsafe(nil)); end
  def each_channel(&block); end
  def force_channel_cleanup_on_close; end
  def get_next_channel_id; end
  def global_request(packet); end
  def io_select_wait(wait); end
  def loop_forever; end
  def request_failure(packet); end
  def request_success(packet); end
end

Net::SSH::Connection::Session::DEFAULT_IO_SELECT_TIMEOUT = T.let(T.unsafe(nil), Integer)
Net::SSH::Connection::Session::MAP = T.let(T.unsafe(nil), Hash)
