# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `geokit` gem.
# Please instead update this file by running `bin/tapioca gem geokit`.

# typed: true

module Geokit
  class << self
    def default_formula; end
    def default_formula=(obj); end
    def default_units; end
    def default_units=(obj); end
  end
end

class Geokit::Bounds
  def initialize(sw, ne); end

  def ==(other); end
  def center; end
  def contains?(point); end
  def crosses_meridian?; end
  def ne; end
  def ne=(_arg0); end
  def sw; end
  def sw=(_arg0); end
  def to_a; end
  def to_s; end
  def to_span; end

  class << self
    def from_point_and_radius(point, radius, options = T.unsafe(nil)); end
    def normalize(thing, other = T.unsafe(nil)); end
  end
end

class Geokit::GeoLoc < ::Geokit::LatLng
  def initialize(h = T.unsafe(nil)); end

  def accuracy; end
  def accuracy=(_arg0); end
  def all; end
  def all=(_arg0); end
  def block_fips; end
  def block_fips=(_arg0); end
  def city; end
  def city=(city); end
  def country; end
  def country=(_arg0); end
  def country_code; end
  def country_code=(_arg0); end
  def district; end
  def district=(_arg0); end
  def district_fips; end
  def district_fips=(_arg0); end
  def encode_with(coder); end
  def formatted_address; end
  def formatted_address=(_arg0); end
  def full_address; end
  def full_address=(_arg0); end
  def hash; end
  def is_us?; end
  def neighborhood; end
  def neighborhood=(_arg0); end
  def place_id; end
  def place_id=(_arg0); end
  def precision; end
  def precision=(_arg0); end
  def provider; end
  def provider=(_arg0); end
  def province; end
  def state; end
  def state=(_arg0); end
  def state_code; end
  def state_code=(_arg0); end
  def state_fips; end
  def state_fips=(_arg0); end
  def state_name; end
  def state_name=(_arg0); end
  def street_address; end
  def street_address=(address); end
  def street_name; end
  def street_name=(_arg0); end
  def street_number; end
  def street_number=(_arg0); end
  def sub_premise; end
  def sub_premise=(_arg0); end
  def success; end
  def success=(_arg0); end
  def success?; end
  def suggested_bounds; end
  def suggested_bounds=(_arg0); end
  def to_geocodeable_s; end
  def to_hash; end
  def to_s; end
  def to_yaml_properties; end
  def zip; end
  def zip=(_arg0); end
end

module Geokit::Geocoders
  class << self
    def __define_accessors; end
    def domain; end
    def domain=(obj); end
    def host; end
    def host=(obj); end
    def ip_provider_order; end
    def ip_provider_order=(obj); end
    def logger; end
    def logger=(obj); end
    def net_adapter; end
    def net_adapter=(obj); end
    def provider_order; end
    def provider_order=(obj); end
    def proxy; end
    def proxy=(obj); end
    def request_timeout; end
    def request_timeout=(obj); end
    def secure; end
    def secure=(obj); end
    def ssl_verify_mode; end
    def ssl_verify_mode=(obj); end
    def useragent; end
    def useragent=(obj); end
  end
end

class Geokit::Geocoders::AccessDeniedError < ::StandardError; end

class Geokit::Geocoders::BaseIpGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def ip?(ip); end
    def private_ip_address?(ip); end
    def process(format, ip); end
    def secure; end
    def secure=(value); end
    def valid_ip?(ip); end
  end
end

Geokit::Geocoders::BaseIpGeocoder::NON_ROUTABLE_IP_RANGES = T.let(T.unsafe(nil), Array)

class Geokit::Geocoders::BingGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_geocode(address, _ = T.unsafe(nil)); end
    def extract_location(xml); end
    def key; end
    def key=(value); end
    def options; end
    def options=(value); end
    def parse_xml(xml); end
    def secure; end
    def secure=(value); end
    def set_address_components(loc, xml); end
    def set_bounds(loc, xml); end
    def set_precision(loc, xml); end
    def submit_url(address); end
  end
end

Geokit::Geocoders::BingGeocoder::ACCURACY_MAP = T.let(T.unsafe(nil), Hash)
Geokit::Geocoders::BingGeocoder::PRECISION_MAP = T.let(T.unsafe(nil), Hash)
Geokit::Geocoders::BingGeocoder::XML_MAPPINGS = T.let(T.unsafe(nil), Hash)

class Geokit::Geocoders::CaGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_geocode(loc, _ = T.unsafe(nil)); end
    def key; end
    def key=(value); end
    def parse_xml(xml, loc); end
    def secure; end
    def secure=(value); end
    def submit_url(loc); end
  end
end

class Geokit::Geocoders::FCCGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_reverse_geocode(latlng); end
    def parse_json(results); end
    def secure; end
    def secure=(value); end
  end
end

class Geokit::Geocoders::FreeGeoIpGeocoder < ::Geokit::Geocoders::BaseIpGeocoder
  class << self
    def do_geocode(ip, _ = T.unsafe(nil)); end
    def parse_xml(xml); end
    def secure; end
    def secure=(value); end
    def submit_url(ip); end
  end
end

Geokit::Geocoders::FreeGeoIpGeocoder::XML_MAPPINGS = T.let(T.unsafe(nil), Hash)

class Geokit::Geocoders::GeoPluginGeocoder < ::Geokit::Geocoders::BaseIpGeocoder
  class << self
    def do_geocode(ip, _ = T.unsafe(nil)); end
    def parse_xml(xml); end
    def secure; end
    def secure=(value); end
    def submit_url(ip); end
  end
end

Geokit::Geocoders::GeoPluginGeocoder::XML_MAPPINGS = T.let(T.unsafe(nil), Hash)

class Geokit::Geocoders::GeobytesGeocoder < ::Geokit::Geocoders::BaseIpGeocoder
  class << self
    def do_geocode(ip, _ = T.unsafe(nil)); end
    def parse_json(json); end
    def secure; end
    def secure=(value); end
    def submit_url(ip); end
  end
end

class Geokit::Geocoders::GeocodeError < ::StandardError; end

class Geokit::Geocoders::Geocoder
  class << self
    def call_geocoder_service(url); end
    def config(*attrs); end
    def do_get(url); end
    def do_reverse_geocode(_latlng); end
    def geocode(address, *args); end
    def inherited(base); end
    def logger; end
    def net_adapter; end
    def new_loc; end
    def parse(format, body, *args); end
    def process(format, url, *args); end
    def protocol; end
    def provider_name; end
    def reverse_geocode(latlng, *args); end
    def set_mappings(loc, xml, mappings); end
    def use_https?; end
  end
end

class Geokit::Geocoders::GeocodioGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def create_new_loc(json); end
    def do_geocode(address, _ = T.unsafe(nil)); end
    def key; end
    def key=(value); end
    def parse_json(json); end
    def secure; end
    def secure=(value); end
    def set_address_components(json, loc); end
    def set_coordinates(json, loc); end
    def submit_url(address); end
  end
end

class Geokit::Geocoders::GeonamesGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_geocode(address, _ = T.unsafe(nil)); end
    def key; end
    def key=(value); end
    def parse_xml(xml); end
    def premium; end
    def premium=(value); end
    def secure; end
    def secure=(value); end
    def submit_url(address); end
  end
end

Geokit::Geocoders::GeonamesGeocoder::XML_MAPPINGS = T.let(T.unsafe(nil), Hash)

class Geokit::Geocoders::GoogleGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def api_key; end
    def api_key=(value); end
    def channel; end
    def channel=(value); end
    def client_id; end
    def client_id=(value); end
    def construct_bias_string_from_options(bias); end
    def construct_components_string_from_options(components = T.unsafe(nil)); end
    def cryptographic_key; end
    def cryptographic_key=(value); end
    def do_geocode(address, options = T.unsafe(nil)); end
    def do_reverse_geocode(latlng, options = T.unsafe(nil)); end
    def host; end
    def host=(value); end
    def parse_json(results); end
    def secure; end
    def secure=(value); end
    def set_address_components(loc, addr); end
    def set_bounds(loc, addr); end
    def set_precision(loc, addr); end
    def sign_gmap_bus_api_url(urlToSign, google_cryptographic_key); end
    def single_json_to_geoloc(addr); end
    def submit_url(query_string, options = T.unsafe(nil)); end
  end
end

Geokit::Geocoders::GoogleGeocoder::ACCURACY = T.let(T.unsafe(nil), Hash)
Geokit::Geocoders::GoogleGeocoder::PRECISIONS = T.let(T.unsafe(nil), Array)

class Geokit::Geocoders::IpApiGeocoder < ::Geokit::Geocoders::BaseIpGeocoder
  class << self
    def do_geocode(ip, _ = T.unsafe(nil)); end
    def parse_json(result); end
    def secure; end
    def secure=(value); end
    def submit_url(ip); end
  end
end

class Geokit::Geocoders::IpGeocoder < ::Geokit::Geocoders::BaseIpGeocoder
  class << self
    def do_geocode(ip, _ = T.unsafe(nil)); end
    def ensure_utf8_encoding(res); end
    def extract_charset(res); end
    def parse_yaml(yaml); end
    def secure; end
    def secure=(value); end
    def submit_url(ip); end
  end
end

class Geokit::Geocoders::IpstackGeocoder < ::Geokit::Geocoders::BaseIpGeocoder
  class << self
    def api_key; end
    def api_key=(value); end
    def do_geocode(ip, _options = T.unsafe(nil)); end
    def parse_json(result); end
    def secure; end
    def secure=(value); end
    def submit_url(ip); end
  end
end

class Geokit::Geocoders::MapQuestGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_geocode(address, _ = T.unsafe(nil)); end
    def do_reverse_geocode(latlng); end
    def extract_geoloc(result_json); end
    def key; end
    def key=(value); end
    def parse_json(results); end
    def secure; end
    def secure=(value); end
    def set_address_components(result_json, loc); end
    def set_precision(result_json, loc); end
  end
end

class Geokit::Geocoders::MapboxGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_geocode(address, _options = T.unsafe(nil)); end
    def do_reverse_geocode(latlng, _options = T.unsafe(nil)); end
    def extract_geoloc(result_json); end
    def key; end
    def key=(value); end
    def parse_json(results); end
    def secure; end
    def secure=(value); end
    def set_address_components(result_json, loc); end
    def set_bounds(bounds, loc); end
    def set_precision(loc); end
  end
end

Geokit::Geocoders::MapboxGeocoder::PRECISION_VALUES = T.let(T.unsafe(nil), Array)

class Geokit::Geocoders::MaxmindGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_geocode(ip, _ = T.unsafe(nil)); end
    def geoip_data_path; end
    def geoip_data_path=(value); end
    def secure; end
    def secure=(value); end
  end
end

class Geokit::Geocoders::MultiGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_geocode(address, *args); end
    def do_reverse_geocode(latlng, *args); end
    def geocoder(provider); end
    def provider_order_for(address, args); end
    def secure; end
    def secure=(value); end
  end
end

class Geokit::Geocoders::OSMGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_geocode(address, options = T.unsafe(nil)); end
    def do_reverse_geocode(latlng, options = T.unsafe(nil)); end
    def extract_geoloc(result_json); end
    def generate_bool_param_for_option(param, options); end
    def generate_param_for(param, value); end
    def generate_param_for_option(param, options); end
    def parse_json(results); end
    def secure; end
    def secure=(value); end
    def set_address_components(address_data, loc); end
    def set_bounds(result_json, loc); end
    def set_precision(result_json, loc); end
  end
end

class Geokit::Geocoders::OpencageGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_geocode(address, options = T.unsafe(nil)); end
    def do_reverse_geocode(latlng); end
    def extract_geoloc(result_json); end
    def generate_bool_param_for_option(param, options); end
    def generate_param_for(param, value); end
    def generate_param_for_option(param, options); end
    def key; end
    def key=(value); end
    def parse_json(results); end
    def secure; end
    def secure=(value); end
    def set_address_components(address_data, loc); end
    def set_precision(result_json, loc); end
  end
end

Geokit::Geocoders::OsmGeocoder = Geokit::Geocoders::OSMGeocoder

class Geokit::Geocoders::RipeGeocoder < ::Geokit::Geocoders::BaseIpGeocoder
  class << self
    def do_geocode(ip, _ = T.unsafe(nil)); end
    def parse_json(json); end
    def secure; end
    def secure=(value); end
    def set_address_components(data, loc); end
    def submit_url(ip); end
  end
end

class Geokit::Geocoders::TooManyQueriesError < ::StandardError; end

class Geokit::Geocoders::UsGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_geocode(address, _ = T.unsafe(nil)); end
    def key; end
    def key=(value); end
    def parse_csv(array); end
    def secure; end
    def secure=(value); end
    def submit_url(address); end
  end
end

class Geokit::Geocoders::YahooGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_geocode(address, _ = T.unsafe(nil)); end
    def extract_geoloc(result_json); end
    def key; end
    def key=(value); end
    def parse_json(results); end
    def secret; end
    def secret=(value); end
    def secure; end
    def secure=(value); end
    def set_address_components(result_json, loc); end
    def set_precision(result_json, loc); end
    def submit_url(address); end
  end
end

class Geokit::Geocoders::YandexGeocoder < ::Geokit::Geocoders::Geocoder
  class << self
    def do_geocode(address, _ = T.unsafe(nil)); end
    def key; end
    def key=(value); end
    def parse_json(result); end
    def secure; end
    def secure=(value); end
    def set_address_components(loc, l, country, locality); end
    def set_precision(loc, l, locality); end
    def submit_url(address); end
  end
end

module Geokit::Inflector
  private

  def camelize(str); end
  def humanize(lower_case_and_underscored_word); end
  def titleize(word); end
  def underscore(camel_cased_word); end
  def url_escape(s); end

  class << self
    def camelize(str); end
    def humanize(lower_case_and_underscored_word); end
    def titleize(word); end
    def underscore(camel_cased_word); end
    def url_escape(s); end
  end
end

class Geokit::LatLng
  include ::Geokit::Mappable
  extend ::Geokit::Mappable::ClassMethods

  def initialize(lat = T.unsafe(nil), lng = T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def lat; end
  def lat=(lat); end
  def lat_dms; end
  def latitude; end
  def latitude=(_arg0); end
  def ll; end
  def lng; end
  def lng=(lng); end
  def lng_dms; end
  def longitude; end
  def longitude=(_arg0); end
  def reverse_geocode(options = T.unsafe(nil)); end
  def to_a; end
  def to_s; end
  def valid?; end

  class << self
    def from_json(json); end
    def from_string(thing); end
    def normalize(thing, other = T.unsafe(nil)); end
  end
end

module Geokit::Mappable
  mixes_in_class_methods ::Geokit::Mappable::ClassMethods

  def distance_from(other, options = T.unsafe(nil)); end
  def distance_to(other, options = T.unsafe(nil)); end
  def endpoint(heading, distance, options = T.unsafe(nil)); end
  def heading_from(other); end
  def heading_to(other); end
  def midpoint_to(other, options = T.unsafe(nil)); end
  def to_lat_lng; end

  class << self
    def included(receiver); end
  end
end

module Geokit::Mappable::ClassMethods
  def decimal_to_dms(deg); end
  def deg2rad(degrees); end
  def distance_between(from, to, options = T.unsafe(nil)); end
  def distance_between_flat(from, to, units); end
  def distance_between_sphere(from, to, units); end
  def endpoint(start, heading, distance, options = T.unsafe(nil)); end
  def geocode(location, options = T.unsafe(nil)); end
  def get_units!(options = T.unsafe(nil)); end
  def heading_between(from, to); end
  def math_error_classes; end
  def midpoint_between(from, to, options = T.unsafe(nil)); end
  def rad2deg(rad); end
  def to_heading(rad); end
  def units_per_latitude_degree(units); end
  def units_per_longitude_degree(lat, units); end
  def units_sphere_multiplier(units); end

  class << self
    def register_unit(key, in_meters); end
  end
end

Geokit::Mappable::ClassMethods::EARTH_RADIUS = T.let(T.unsafe(nil), Hash)
Geokit::Mappable::ClassMethods::EARTH_RADIUS_IN_METERS = T.let(T.unsafe(nil), Float)
Geokit::Mappable::ClassMethods::METERS_PER_LATITUDE_DEGREE = T.let(T.unsafe(nil), Float)
Geokit::Mappable::ClassMethods::PER_LATITUDE_DEGREE = T.let(T.unsafe(nil), Hash)
Geokit::Mappable::ClassMethods::PI_DIV_RAD = T.let(T.unsafe(nil), Float)
module Geokit::NetAdapter; end

class Geokit::NetAdapter::NetHttp
  class << self
    def do_get(url); end
    def success?(response); end
  end
end

class Geokit::NetAdapter::Typhoeus
  class << self
    def do_get(url); end
    def success?(response); end
  end
end

class Geokit::Polygon
  def initialize(points); end

  def centroid; end
  def contains?(point); end
  def points; end
  def points=(_arg0); end

  private

  def calculate_centroid; end
end

class OauthUtil
  def initialize; end

  def base_str; end
  def base_str=(_arg0); end
  def callback_url; end
  def callback_url=(_arg0); end
  def consumer_key; end
  def consumer_key=(_arg0); end
  def consumer_secret; end
  def consumer_secret=(_arg0); end
  def nonce; end
  def oauth_version; end
  def oauth_version=(_arg0); end
  def params; end
  def params=(_arg0); end
  def percent_encode(string); end
  def query_string; end
  def req_method; end
  def req_method=(_arg0); end
  def req_url; end
  def req_url=(_arg0); end
  def sig_method; end
  def sig_method=(_arg0); end
  def sign(parsed_url); end
  def signature; end
  def timestamp; end
  def token; end
  def token=(_arg0); end
  def token_secret; end
  def token_secret=(_arg0); end
end
