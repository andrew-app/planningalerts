# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/mime-types/all/mime-types.rbi
#
# mime-types-2.99.3

module MIME
  def self.const_missing(name); end
  def self.warn_about_moved_constants(name); end
end
class MIME::Types
  def [](type_id, flags = nil); end
  def add(*types); end
  def add_type(type, quiet = nil); end
  def add_type_variant!(mime_type); end
  def add_type_variant(mime_type); end
  def count; end
  def data_version; end
  def defined_types; end
  def each; end
  def index_extensions!(mime_type); end
  def index_extensions(mime_type); end
  def initialize; end
  def match(pattern); end
  def of(filename, platform = nil); end
  def prune_matches(matches, flags); end
  def self.[](type_id, flags = nil); end
  def self.__types__; end
  def self.add(*types); end
  def self.add_type_variant(mime_type); end
  def self.cache_file; end
  def self.count; end
  def self.deprecated(klass, sym, message = nil, &block); end
  def self.each; end
  def self.index_extensions(mime_type); end
  def self.lazy_load?; end
  def self.load_default_mime_types(mode = nil); end
  def self.load_from_file(filename); end
  def self.load_mode; end
  def self.logger; end
  def self.logger=(arg0); end
  def self.of(filename, platform = nil); end
  def self.type_for(filename, platform = nil); end
  def type_for(filename, platform = nil); end
  include Enumerable
end
class MIME::Types::WarnLogger < Logger
  def initialize(_1, _2 = nil, _3 = nil); end
end
class MIME::Types::WarnLogger::WarnLogDevice < Logger::LogDevice
  def close; end
  def initialize(*arg0); end
  def write(m); end
end
class MIME::Type
  def <=>(other); end
  def add_extensions(*extensions); end
  def ascii?; end
  def binary?; end
  def complete?; end
  def content_type; end
  def content_type=(type_string); end
  def default_encoding; end
  def docs; end
  def docs=(arg0); end
  def encode_with(coder); end
  def encoding; end
  def encoding=(enc); end
  def eql?(other); end
  def extensions; end
  def extensions=(ext); end
  def friendly(lang = nil); end
  def i18n_key; end
  def init_with(coder); end
  def initialize(content_type); end
  def like?(other); end
  def media_type; end
  def obsolete=(v); end
  def obsolete?; end
  def platform?(*arg0); end
  def preferred_extension; end
  def priority_compare(other); end
  def raw_media_type; end
  def raw_sub_type; end
  def references(*arg0); end
  def references=(_r); end
  def registered=(v); end
  def registered?; end
  def self.from_array(*args); end
  def self.from_hash(hash); end
  def self.from_mime_type(mime_type); end
  def self.i18n_key(content_type); end
  def self.simplified(content_type); end
  def signature=(v); end
  def signature?; end
  def simplified; end
  def sub_type; end
  def system; end
  def system=(_os); end
  def system?(*arg0); end
  def to_a; end
  def to_h; end
  def to_hash; end
  def to_json(*args); end
  def to_s; end
  def to_str; end
  def url; end
  def url=(_r); end
  def urls; end
  def use_instead; end
  def use_instead=(arg0); end
  def xref_urls; end
  def xrefs; end
  def xrefs=(x); end
  include Comparable
end
class MIME::Type::InvalidContentType < ArgumentError
  def initialize(type_string); end
  def to_s; end
end
class MIME::Type::InvalidEncoding < ArgumentError
  def initialize(encoding); end
  def to_s; end
end
class MIME::Types::Cache < Struct
  def data; end
  def data=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.load(cache_file = nil); end
  def self.members; end
  def self.new(*arg0); end
  def self.save(types = nil, cache_file = nil); end
  def version; end
  def version=(_); end
end
class MIME::Types::Container < Hash
  def initialize; end
  def marshal_dump; end
  def marshal_load(hash); end
end
class MIME::Types::Loader
  def columnar_path; end
  def container; end
  def initialize(path = nil, container = nil); end
  def json_path; end
  def load(options = nil); end
  def load_columnar; end
  def load_json; end
  def load_v1; end
  def load_yaml; end
  def path; end
  def self.load(options = nil); end
  def self.load_from_json(filename); end
  def self.load_from_v1(filename, __internal__ = nil); end
  def self.load_from_yaml(filename); end
  def self.read_file(filename); end
  def v1_path; end
  def yaml_path; end
end
class MIME::Types::Loader::BadV1Format < Exception
end
class MIME::Type::Columnar < MIME::Type
  def binary?; end
  def docs; end
  def encode_with(coder); end
  def encoding; end
  def friendly(*arg0); end
  def friendly=(arg0); end
  def initialize(container, content_type, extensions); end
  def obsolete?; end
  def registered?; end
  def signature?; end
  def to_a; end
  def to_hash; end
  def use_instead; end
  def xrefs; end
end
module MIME::Types::Columnar
  def arr(line); end
  def bool(line); end
  def dict(line); end
  def each_file_line(name, lookup = nil); end
  def load_base_data(path); end
  def load_docs; end
  def load_encoding; end
  def load_friendly; end
  def load_obsolete; end
  def load_registered; end
  def load_signature; end
  def load_use_instead; end
  def load_xrefs; end
  def self.extended(obj); end
end
