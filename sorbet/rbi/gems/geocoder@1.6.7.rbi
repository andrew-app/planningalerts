# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `geocoder` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module Geocoder
  class << self
    def address(query, options = T.unsafe(nil)); end
    def config; end
    def config_for_lookup(lookup_name); end
    def configure(options = T.unsafe(nil), &block); end
    def coordinates(address, options = T.unsafe(nil)); end
    def log(level, message); end
    def merge_into_lookup_config(lookup_name, options); end
    def search(query, options = T.unsafe(nil)); end
  end
end

class Geocoder::Cache
  def initialize(store, prefix); end

  def [](url); end
  def []=(url, value); end
  def expire(url); end

  private

  def expire_single_url(url); end
  def interpret(value); end
  def key_for(url); end
  def keys; end
  def prefix; end
  def store; end
  def urls; end
end

module Geocoder::Calculations
  extend(::Geocoder::Calculations)

  def bearing_between(point1, point2, options = T.unsafe(nil)); end
  def bounding_box(point, radius, options = T.unsafe(nil)); end
  def compass_point(bearing, points = T.unsafe(nil)); end
  def coordinates_present?(*args); end
  def distance_between(point1, point2, options = T.unsafe(nil)); end
  def distance_to_radians(distance, units = T.unsafe(nil)); end
  def earth_radius(units = T.unsafe(nil)); end
  def endpoint(start, heading, distance, options = T.unsafe(nil)); end
  def extract_coordinates(point); end
  def geographic_center(points); end
  def km_in_mi; end
  def km_in_nm; end
  def latitude_degree_distance(units = T.unsafe(nil)); end
  def longitude_degree_distance(latitude, units = T.unsafe(nil)); end
  def mi_in_km; end
  def nm_in_km; end
  def radians_to_distance(radians, units = T.unsafe(nil)); end
  def random_point_near(center, radius, options = T.unsafe(nil)); end
  def to_degrees(*args); end
  def to_kilometers(mi); end
  def to_miles(km); end
  def to_nautical_miles(km); end
  def to_radians(*args); end
end

Geocoder::Calculations::COMPASS_POINTS = T.let(T.unsafe(nil), Array)

Geocoder::Calculations::DEGREES_PER_RADIAN = T.let(T.unsafe(nil), Float)

Geocoder::Calculations::EARTH_RADII = T.let(T.unsafe(nil), Hash)

Geocoder::Calculations::EARTH_RADIUS = T.let(T.unsafe(nil), Float)

Geocoder::Calculations::KM_IN_MI = T.let(T.unsafe(nil), Float)

Geocoder::Calculations::KM_IN_NM = T.let(T.unsafe(nil), Float)

Geocoder::Calculations::NAN = T.let(T.unsafe(nil), Float)

class Geocoder::Configuration
  include(::Singleton)
  extend(::Singleton::SingletonClassMethods)

  def initialize; end

  def always_raise; end
  def always_raise=(value); end
  def api_key; end
  def api_key=(value); end
  def basic_auth; end
  def basic_auth=(value); end
  def cache; end
  def cache=(value); end
  def cache_prefix; end
  def cache_prefix=(value); end
  def configure(options); end
  def data; end
  def data=(_arg0); end
  def distances; end
  def distances=(value); end
  def http_headers; end
  def http_headers=(value); end
  def http_proxy; end
  def http_proxy=(value); end
  def https_proxy; end
  def https_proxy=(value); end
  def ip_lookup; end
  def ip_lookup=(value); end
  def kernel_logger_level; end
  def kernel_logger_level=(value); end
  def language; end
  def language=(value); end
  def logger; end
  def logger=(value); end
  def lookup; end
  def lookup=(value); end
  def set_defaults; end
  def timeout; end
  def timeout=(value); end
  def units; end
  def units=(value); end
  def use_https; end
  def use_https=(value); end

  class << self
    def always_raise; end
    def always_raise=(value); end
    def api_key; end
    def api_key=(value); end
    def basic_auth; end
    def basic_auth=(value); end
    def cache; end
    def cache=(value); end
    def cache_prefix; end
    def cache_prefix=(value); end
    def distances; end
    def distances=(value); end
    def http_headers; end
    def http_headers=(value); end
    def http_proxy; end
    def http_proxy=(value); end
    def https_proxy; end
    def https_proxy=(value); end
    def instance; end
    def ip_lookup; end
    def ip_lookup=(value); end
    def kernel_logger_level; end
    def kernel_logger_level=(value); end
    def language; end
    def language=(value); end
    def logger; end
    def logger=(value); end
    def lookup; end
    def lookup=(value); end
    def set_defaults; end
    def timeout; end
    def timeout=(value); end
    def units; end
    def units=(value); end
    def use_https; end
    def use_https=(value); end
  end
end

Geocoder::Configuration::OPTIONS = T.let(T.unsafe(nil), Array)

class Geocoder::ConfigurationError < ::Geocoder::Error
end

class Geocoder::ConfigurationHash < ::Hash
  def method_missing(meth, *args, &block); end

  private

  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

class Geocoder::Error < ::StandardError
end

class Geocoder::InvalidApiKey < ::Geocoder::Error
end

class Geocoder::InvalidRequest < ::Geocoder::Error
end

class Geocoder::IpAddress < ::String
  def internal?; end
  def loopback?; end
  def private?; end
  def valid?; end
end

Geocoder::IpAddress::PRIVATE_IPS = T.let(T.unsafe(nil), Array)

class Geocoder::KernelLogger
  include(::Singleton)
  extend(::Singleton::SingletonClassMethods)

  def add(level, message); end

  private

  def log_message_at_level?(level); end

  class << self
    def instance; end
  end
end

class Geocoder::Logger
  include(::Singleton)
  extend(::Singleton::SingletonClassMethods)

  def log(level, message); end

  private

  def current_logger; end
  def valid_level?(level); end

  class << self
    def instance; end
  end
end

Geocoder::Logger::SEVERITY = T.let(T.unsafe(nil), Hash)

module Geocoder::Lookup
  extend(::Geocoder::Lookup)

  def all_services; end
  def all_services_except_test; end
  def get(name); end
  def ip_services; end
  def ip_services=(_arg0); end
  def street_services; end
  def street_services=(_arg0); end

  private

  def classify_name(filename); end
  def spawn(name); end
end

class Geocoder::Lookup::Base
  def initialize; end

  def cache; end
  def handle; end
  def map_link_url(coordinates); end
  def name; end
  def query_url(query); end
  def required_api_key_parts; end
  def search(query, options = T.unsafe(nil)); end
  def supported_protocols; end

  private

  def base_query_url(query); end
  def cache_key(query); end
  def cache_key_params(query); end
  def check_api_key_configuration!(query); end
  def check_response_for_errors!(response); end
  def configuration; end
  def configure_ssl!(client); end
  def fetch_data(query); end
  def fetch_raw_data(query); end
  def hash_to_query(hash); end
  def http_client; end
  def make_api_request(query); end
  def parse_json(data); end
  def parse_raw_data(raw_data); end
  def protocol; end
  def query_url_params(query); end
  def raise_error(error, message = T.unsafe(nil)); end
  def result_class; end
  def results(query); end
  def url_query_string(query); end
  def use_ssl?; end
  def valid_response?(response); end
end

class Geocoder::Lookup::Test < ::Geocoder::Lookup::Base
  def name; end

  private

  def results(query); end

  class << self
    def add_stub(query_text, results); end
    def delete_stub(query_text); end
    def read_stub(query_text); end
    def reset; end
    def set_default_stub(results); end
    def stubs; end
  end
end

class Geocoder::LookupTimeout < ::Timeout::Error
end

module Geocoder::Model
end

module Geocoder::Model::ActiveRecord
  include(::Geocoder::Model::Base)

  def geocoded_by(address_attr, options = T.unsafe(nil), &block); end
  def reverse_geocoded_by(latitude_attr, longitude_attr, options = T.unsafe(nil), &block); end

  private

  def geocoder_file_name; end
  def geocoder_module_name; end
end

module Geocoder::Model::Base
  def geocoded_by; end
  def geocoder_options; end
  def reverse_geocoded_by; end

  private

  def geocoder_init(options); end
end

class Geocoder::NetworkError < ::Geocoder::Error
end

class Geocoder::OverQueryLimitError < ::Geocoder::Error
end

class Geocoder::Query
  def initialize(text, options = T.unsafe(nil)); end

  def blank?; end
  def coordinates; end
  def coordinates?; end
  def execute; end
  def internal_ip_address?; end
  def ip_address?; end
  def language; end
  def lookup; end
  def loopback_ip_address?; end
  def options; end
  def options=(_arg0); end
  def private_ip_address?; end
  def reverse_geocode?; end
  def sanitized_text; end
  def text; end
  def text=(_arg0); end
  def to_s; end
  def url; end

  private

  def params_given?; end
end

class Geocoder::Railtie < ::Rails::Railtie
  class << self
    def insert; end
  end
end

module Geocoder::Request
  def geocoder_spoofable_ip; end
  def location; end
  def safe_location; end

  private

  def geocoder_reject_non_ipv4_addresses(ip_addresses); end
  def geocoder_reject_trusted_ip_addresses(ip_addresses); end
  def geocoder_remove_port_from_addresses(ip_addresses); end
  def geocoder_split_ip_addresses(ip_addresses); end
end

Geocoder::Request::GEOCODER_CANDIDATE_HEADERS = T.let(T.unsafe(nil), Array)

class Geocoder::RequestDenied < ::Geocoder::Error
end

class Geocoder::ResponseParseError < ::Geocoder::Error
  def initialize(response); end

  def response; end
end

module Geocoder::Result
end

class Geocoder::Result::Base
  def initialize(data); end

  def address(format = T.unsafe(nil)); end
  def cache_hit; end
  def cache_hit=(_arg0); end
  def coordinates; end
  def country; end
  def country_code; end
  def data; end
  def data=(_arg0); end
  def latitude; end
  def longitude; end
  def province; end
  def province_code; end
  def state; end
  def state_code; end
end

class Geocoder::Result::Test < ::Geocoder::Result::Base
  def initialize(data); end

  def address; end
  def city; end
  def coordinates; end
  def country; end
  def country_code; end
  def geometry; end
  def neighborhood; end
  def postal_code; end
  def province; end
  def province_code; end
  def route; end
  def state; end
  def state_code; end
  def street_address; end
  def street_number; end
  def sub_state; end
  def sub_state_code; end

  class << self
    def add_result_attribute(attr); end
  end
end

class Geocoder::ServiceUnavailable < ::Geocoder::Error
end

module Geocoder::Util
  class << self
    def recursive_hash_merge(h1, h2); end
  end
end
