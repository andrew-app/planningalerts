# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/geokit/all/geokit.rbi
#
# geokit-1.13.1

module Geokit
  def self.default_formula; end
  def self.default_formula=(obj); end
  def self.default_units; end
  def self.default_units=(obj); end
end
module Geokit::NetAdapter
end
class Geokit::NetAdapter::NetHttp
  def self.do_get(url); end
  def self.success?(response); end
end
class Geokit::NetAdapter::Typhoeus
  def self.do_get(url); end
  def self.success?(response); end
end
module Geokit::Inflector
  def camelize(str); end
  def humanize(lower_case_and_underscored_word); end
  def self.camelize(str); end
  def self.humanize(lower_case_and_underscored_word); end
  def self.titleize(word); end
  def self.underscore(camel_cased_word); end
  def self.url_escape(s); end
  def titleize(word); end
  def underscore(camel_cased_word); end
  def url_escape(s); end
end
module Geokit::Geocoders
  def self.__define_accessors; end
  def self.domain; end
  def self.domain=(obj); end
  def self.host; end
  def self.host=(obj); end
  def self.ip_provider_order; end
  def self.ip_provider_order=(obj); end
  def self.logger; end
  def self.logger=(obj); end
  def self.net_adapter; end
  def self.net_adapter=(obj); end
  def self.provider_order; end
  def self.provider_order=(obj); end
  def self.proxy; end
  def self.proxy=(obj); end
  def self.request_timeout; end
  def self.request_timeout=(obj); end
  def self.secure; end
  def self.secure=(obj); end
  def self.ssl_verify_mode; end
  def self.ssl_verify_mode=(obj); end
  def self.useragent; end
  def self.useragent=(obj); end
end
class Geokit::Geocoders::BaseIpGeocoder < Geokit::Geocoders::Geocoder
  def self.ip?(ip); end
  def self.private_ip_address?(ip); end
  def self.process(format, ip); end
  def self.secure; end
  def self.secure=(value); end
  def self.valid_ip?(ip); end
end
class Geokit::Geocoders::CaGeocoder < Geokit::Geocoders::Geocoder
  def self.do_geocode(loc, _ = nil); end
  def self.key; end
  def self.key=(value); end
  def self.parse_xml(xml, loc); end
  def self.secure; end
  def self.secure=(value); end
  def self.submit_url(loc); end
end
class Geokit::Geocoders::IpGeocoder < Geokit::Geocoders::BaseIpGeocoder
  def self.do_geocode(ip, _ = nil); end
  def self.ensure_utf8_encoding(res); end
  def self.extract_charset(res); end
  def self.parse_yaml(yaml); end
  def self.secure; end
  def self.secure=(value); end
  def self.submit_url(ip); end
end
class Geokit::Geocoders::IpApiGeocoder < Geokit::Geocoders::BaseIpGeocoder
  def self.do_geocode(ip, _ = nil); end
  def self.parse_json(result); end
  def self.secure; end
  def self.secure=(value); end
  def self.submit_url(ip); end
end
class Geokit::Geocoders::GeoPluginGeocoder < Geokit::Geocoders::BaseIpGeocoder
  def self.do_geocode(ip, _ = nil); end
  def self.parse_xml(xml); end
  def self.secure; end
  def self.secure=(value); end
  def self.submit_url(ip); end
end
class Geokit::Geocoders::GeocodioGeocoder < Geokit::Geocoders::Geocoder
  def self.create_new_loc(json); end
  def self.do_geocode(address, _ = nil); end
  def self.key; end
  def self.key=(value); end
  def self.parse_json(json); end
  def self.secure; end
  def self.secure=(value); end
  def self.set_address_components(json, loc); end
  def self.set_coordinates(json, loc); end
  def self.submit_url(address); end
end
class Geokit::Geocoders::OpencageGeocoder < Geokit::Geocoders::Geocoder
  def self.do_geocode(address, options = nil); end
  def self.do_reverse_geocode(latlng); end
  def self.extract_geoloc(result_json); end
  def self.generate_bool_param_for_option(param, options); end
  def self.generate_param_for(param, value); end
  def self.generate_param_for_option(param, options); end
  def self.key; end
  def self.key=(value); end
  def self.parse_json(results); end
  def self.secure; end
  def self.secure=(value); end
  def self.set_address_components(address_data, loc); end
  def self.set_precision(result_json, loc); end
end
class Geokit::Geocoders::MaxmindGeocoder < Geokit::Geocoders::Geocoder
  def self.do_geocode(ip, _ = nil); end
  def self.geoip_data_path; end
  def self.geoip_data_path=(value); end
  def self.secure; end
  def self.secure=(value); end
end
class Geokit::Geocoders::BingGeocoder < Geokit::Geocoders::Geocoder
  def self.do_geocode(address, _ = nil); end
  def self.extract_location(xml); end
  def self.key; end
  def self.key=(value); end
  def self.options; end
  def self.options=(value); end
  def self.parse_xml(xml); end
  def self.secure; end
  def self.secure=(value); end
  def self.set_address_components(loc, xml); end
  def self.set_bounds(loc, xml); end
  def self.set_precision(loc, xml); end
  def self.submit_url(address); end
end
class Geokit::Geocoders::YahooGeocoder < Geokit::Geocoders::Geocoder
  def self.do_geocode(address, _ = nil); end
  def self.extract_geoloc(result_json); end
  def self.key; end
  def self.key=(value); end
  def self.parse_json(results); end
  def self.secret; end
  def self.secret=(value); end
  def self.secure; end
  def self.secure=(value); end
  def self.set_address_components(result_json, loc); end
  def self.set_precision(result_json, loc); end
  def self.submit_url(address); end
end
class OauthUtil
  def base_str; end
  def base_str=(arg0); end
  def callback_url; end
  def callback_url=(arg0); end
  def consumer_key; end
  def consumer_key=(arg0); end
  def consumer_secret; end
  def consumer_secret=(arg0); end
  def initialize; end
  def nonce; end
  def oauth_version; end
  def oauth_version=(arg0); end
  def params; end
  def params=(arg0); end
  def percent_encode(string); end
  def query_string; end
  def req_method; end
  def req_method=(arg0); end
  def req_url; end
  def req_url=(arg0); end
  def sig_method; end
  def sig_method=(arg0); end
  def sign(parsed_url); end
  def signature; end
  def timestamp; end
  def token; end
  def token=(arg0); end
  def token_secret; end
  def token_secret=(arg0); end
end
class Geokit::Geocoders::RipeGeocoder < Geokit::Geocoders::BaseIpGeocoder
  def self.do_geocode(ip, _ = nil); end
  def self.parse_json(json); end
  def self.secure; end
  def self.secure=(value); end
  def self.set_address_components(data, loc); end
  def self.submit_url(ip); end
end
class Geokit::Geocoders::GeonamesGeocoder < Geokit::Geocoders::Geocoder
  def self.do_geocode(address, _ = nil); end
  def self.key; end
  def self.key=(value); end
  def self.parse_xml(xml); end
  def self.premium; end
  def self.premium=(value); end
  def self.secure; end
  def self.secure=(value); end
  def self.submit_url(address); end
end
class Geokit::Geocoders::FreeGeoIpGeocoder < Geokit::Geocoders::BaseIpGeocoder
  def self.do_geocode(ip, _ = nil); end
  def self.parse_xml(xml); end
  def self.secure; end
  def self.secure=(value); end
  def self.submit_url(ip); end
end
class Geokit::Geocoders::YandexGeocoder < Geokit::Geocoders::Geocoder
  def self.do_geocode(address, _ = nil); end
  def self.key; end
  def self.key=(value); end
  def self.parse_json(result); end
  def self.secure; end
  def self.secure=(value); end
  def self.set_address_components(loc, l, country, locality); end
  def self.set_precision(loc, l, locality); end
  def self.submit_url(address); end
end
class Geokit::Geocoders::GeobytesGeocoder < Geokit::Geocoders::BaseIpGeocoder
  def self.do_geocode(ip, _ = nil); end
  def self.parse_json(json); end
  def self.secure; end
  def self.secure=(value); end
  def self.submit_url(ip); end
end
class Geokit::Geocoders::GoogleGeocoder < Geokit::Geocoders::Geocoder
  def self.api_key; end
  def self.api_key=(value); end
  def self.channel; end
  def self.channel=(value); end
  def self.client_id; end
  def self.client_id=(value); end
  def self.construct_bias_string_from_options(bias); end
  def self.construct_components_string_from_options(components = nil); end
  def self.cryptographic_key; end
  def self.cryptographic_key=(value); end
  def self.do_geocode(address, options = nil); end
  def self.do_reverse_geocode(latlng, options = nil); end
  def self.host; end
  def self.host=(value); end
  def self.parse_json(results); end
  def self.secure; end
  def self.secure=(value); end
  def self.set_address_components(loc, addr); end
  def self.set_bounds(loc, addr); end
  def self.set_precision(loc, addr); end
  def self.sign_gmap_bus_api_url(urlToSign, google_cryptographic_key); end
  def self.single_json_to_geoloc(addr); end
  def self.submit_url(query_string, options = nil); end
end
class Geokit::Geocoders::UsGeocoder < Geokit::Geocoders::Geocoder
  def self.do_geocode(address, _ = nil); end
  def self.key; end
  def self.key=(value); end
  def self.parse_csv(array); end
  def self.secure; end
  def self.secure=(value); end
  def self.submit_url(address); end
end
class Geokit::Geocoders::MapboxGeocoder < Geokit::Geocoders::Geocoder
  def self.do_geocode(address, _options = nil); end
  def self.do_reverse_geocode(latlng, _options = nil); end
  def self.extract_geoloc(result_json); end
  def self.key; end
  def self.key=(value); end
  def self.parse_json(results); end
  def self.secure; end
  def self.secure=(value); end
  def self.set_address_components(result_json, loc); end
  def self.set_bounds(bounds, loc); end
  def self.set_precision(loc); end
end
class Geokit::Geocoders::FCCGeocoder < Geokit::Geocoders::Geocoder
  def self.do_reverse_geocode(latlng); end
  def self.parse_json(results); end
  def self.secure; end
  def self.secure=(value); end
end
class Geokit::Geocoders::IpstackGeocoder < Geokit::Geocoders::BaseIpGeocoder
  def self.api_key; end
  def self.api_key=(value); end
  def self.do_geocode(ip, _options = nil); end
  def self.parse_json(result); end
  def self.secure; end
  def self.secure=(value); end
  def self.submit_url(ip); end
end
class Geokit::Geocoders::MapQuestGeocoder < Geokit::Geocoders::Geocoder
  def self.do_geocode(address, _ = nil); end
  def self.do_reverse_geocode(latlng); end
  def self.extract_geoloc(result_json); end
  def self.key; end
  def self.key=(value); end
  def self.parse_json(results); end
  def self.secure; end
  def self.secure=(value); end
  def self.set_address_components(result_json, loc); end
  def self.set_precision(result_json, loc); end
end
class Geokit::Geocoders::OSMGeocoder < Geokit::Geocoders::Geocoder
  def self.do_geocode(address, options = nil); end
  def self.do_reverse_geocode(latlng, options = nil); end
  def self.extract_geoloc(result_json); end
  def self.generate_bool_param_for_option(param, options); end
  def self.generate_param_for(param, value); end
  def self.generate_param_for_option(param, options); end
  def self.parse_json(results); end
  def self.secure; end
  def self.secure=(value); end
  def self.set_address_components(address_data, loc); end
  def self.set_bounds(result_json, loc); end
  def self.set_precision(result_json, loc); end
end
class Geokit::Geocoders::MultiGeocoder < Geokit::Geocoders::Geocoder
  def self.do_geocode(address, *args); end
  def self.do_reverse_geocode(latlng, *args); end
  def self.geocoder(provider); end
  def self.provider_order_for(address, args); end
  def self.secure; end
  def self.secure=(value); end
end
class Geokit::Geocoders::GeocodeError < StandardError
end
class Geokit::Geocoders::TooManyQueriesError < StandardError
end
class Geokit::Geocoders::AccessDeniedError < StandardError
end
class Geokit::Geocoders::Geocoder
  def self.call_geocoder_service(url); end
  def self.config(*attrs); end
  def self.do_get(url); end
  def self.do_reverse_geocode(_latlng); end
  def self.geocode(address, *args); end
  def self.inherited(base); end
  def self.logger; end
  def self.net_adapter; end
  def self.new_loc; end
  def self.parse(format, body, *args); end
  def self.process(format, url, *args); end
  def self.protocol; end
  def self.provider_name; end
  def self.reverse_geocode(latlng, *args); end
  def self.set_mappings(loc, xml, mappings); end
  def self.use_https?; end
end
module Geokit::Mappable
  def distance_from(other, options = nil); end
  def distance_to(other, options = nil); end
  def endpoint(heading, distance, options = nil); end
  def heading_from(other); end
  def heading_to(other); end
  def midpoint_to(other, options = nil); end
  def self.included(receiver); end
  def to_lat_lng; end
end
module Geokit::Mappable::ClassMethods
  def decimal_to_dms(deg); end
  def deg2rad(degrees); end
  def distance_between(from, to, options = nil); end
  def distance_between_flat(from, to, units); end
  def distance_between_sphere(from, to, units); end
  def endpoint(start, heading, distance, options = nil); end
  def geocode(location, options = nil); end
  def get_units!(options = nil); end
  def heading_between(from, to); end
  def math_error_classes; end
  def midpoint_between(from, to, options = nil); end
  def rad2deg(rad); end
  def self.register_unit(key, in_meters); end
  def to_heading(rad); end
  def units_per_latitude_degree(units); end
  def units_per_longitude_degree(lat, units); end
  def units_sphere_multiplier(units); end
end
class Geokit::Bounds
  def ==(other); end
  def center; end
  def contains?(point); end
  def crosses_meridian?; end
  def initialize(sw, ne); end
  def ne; end
  def ne=(arg0); end
  def self.from_point_and_radius(point, radius, options = nil); end
  def self.normalize(thing, other = nil); end
  def sw; end
  def sw=(arg0); end
  def to_a; end
  def to_s; end
  def to_span; end
end
class Geokit::LatLng
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(lat = nil, lng = nil); end
  def lat; end
  def lat=(lat); end
  def lat_dms; end
  def latitude; end
  def latitude=(arg0); end
  def ll; end
  def lng; end
  def lng=(lng); end
  def lng_dms; end
  def longitude; end
  def longitude=(arg0); end
  def reverse_geocode(options = nil); end
  def self.from_json(json); end
  def self.from_string(thing); end
  def self.normalize(thing, other = nil); end
  def to_a; end
  def to_s; end
  def valid?; end
  extend Geokit::Mappable::ClassMethods
  include Geokit::Mappable
end
class Geokit::GeoLoc < Geokit::LatLng
  def accuracy; end
  def accuracy=(arg0); end
  def all; end
  def all=(arg0); end
  def block_fips; end
  def block_fips=(arg0); end
  def city; end
  def city=(city); end
  def country; end
  def country=(arg0); end
  def country_code; end
  def country_code=(arg0); end
  def district; end
  def district=(arg0); end
  def district_fips; end
  def district_fips=(arg0); end
  def encode_with(coder); end
  def formatted_address; end
  def formatted_address=(arg0); end
  def full_address; end
  def full_address=(arg0); end
  def hash; end
  def initialize(h = nil); end
  def is_us?; end
  def neighborhood; end
  def neighborhood=(arg0); end
  def place_id; end
  def place_id=(arg0); end
  def precision; end
  def precision=(arg0); end
  def provider; end
  def provider=(arg0); end
  def province; end
  def state; end
  def state=(arg0); end
  def state_code; end
  def state_code=(arg0); end
  def state_fips; end
  def state_fips=(arg0); end
  def state_name; end
  def state_name=(arg0); end
  def street_address; end
  def street_address=(address); end
  def street_name; end
  def street_name=(arg0); end
  def street_number; end
  def street_number=(arg0); end
  def sub_premise; end
  def sub_premise=(arg0); end
  def success; end
  def success=(arg0); end
  def success?; end
  def suggested_bounds; end
  def suggested_bounds=(arg0); end
  def to_geocodeable_s; end
  def to_hash; end
  def to_s; end
  def to_yaml_properties; end
  def zip; end
  def zip=(arg0); end
end
class Geokit::Polygon
  def calculate_centroid; end
  def centroid; end
  def contains?(point); end
  def initialize(points); end
  def points; end
  def points=(arg0); end
end
