# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `thin` gem.
# Please instead update this file by running `bin/tapioca gem thin`.

# typed: true

module Process
  private

  def running?(pid); end

  class << self
    def running?(pid); end
  end
end

module Rack
  class << self
    def release; end
    def version; end
  end
end

Rack::ADAPTERS = T.let(T.unsafe(nil), Array)

module Rack::Adapter
  class << self
    def for(name, options = T.unsafe(nil)); end
    def guess(dir); end
    def load(config); end
  end
end

class Rack::Adapter::Rails
  def initialize(options = T.unsafe(nil)); end

  def call(env); end
  def file_exist?(path); end
  def load_application; end

  class << self
    def rack_based?; end
  end
end

class Rack::Adapter::Rails::CGIWrapper < ::CGI
  def initialize(request, response, *args); end

  def args; end
  def cookies; end
  def env_table; end
  def header(options = T.unsafe(nil)); end
  def params; end
  def query_string; end
  def stdinput; end
  def stdoutput; end
end

class Rack::Adapter::Rails::CgiApp
  def call(env); end
end

Rack::Adapter::Rails::FILE_METHODS = T.let(T.unsafe(nil), Array)
class Rack::AdapterNotFound < ::RuntimeError; end
Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Rack::DELETE = T.let(T.unsafe(nil), String)
Rack::ETAG = T.let(T.unsafe(nil), String)
Rack::EXPIRES = T.let(T.unsafe(nil), String)
Rack::File = Rack::Files
Rack::GET = T.let(T.unsafe(nil), String)
Rack::HEAD = T.let(T.unsafe(nil), String)
Rack::HTTPS = T.let(T.unsafe(nil), String)
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)

module Rack::Handler
  class << self
    def default; end
    def get(server); end
    def pick(server_names); end
    def register(server, klass); end
    def try_require(prefix, const_name); end
  end
end

class Rack::Handler::Thin
  class << self
    def run(app, **options); end
    def valid_options; end
  end
end

Rack::LINK = T.let(T.unsafe(nil), String)
Rack::OPTIONS = T.let(T.unsafe(nil), String)
Rack::PATCH = T.let(T.unsafe(nil), String)
Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Rack::POST = T.let(T.unsafe(nil), String)
Rack::PUT = T.let(T.unsafe(nil), String)
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)
Rack::RELEASE = T.let(T.unsafe(nil), String)
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)
Rack::TRACE = T.let(T.unsafe(nil), String)
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
Rack::UNLINK = T.let(T.unsafe(nil), String)
Rack::VERSION = T.let(T.unsafe(nil), Array)

module Thin
  class << self
    def linux?; end
    def ruby_18?; end
    def win?; end
  end
end

module Thin::Backends; end

class Thin::Backends::Base
  def initialize; end

  def close; end
  def config; end
  def connection_finished(connection); end
  def empty?; end
  def maximum_connections; end
  def maximum_connections=(_arg0); end
  def maximum_persistent_connections; end
  def maximum_persistent_connections=(_arg0); end
  def no_epoll; end
  def no_epoll=(_arg0); end
  def persistent_connection_count; end
  def persistent_connection_count=(_arg0); end
  def running?; end
  def server; end
  def server=(_arg0); end
  def size; end
  def ssl=(_arg0); end
  def ssl?; end
  def ssl_options=(_arg0); end
  def start; end
  def started_reactor?; end
  def stop; end
  def stop!; end
  def threaded=(_arg0); end
  def threaded?; end
  def threadpool_size; end
  def threadpool_size=(size); end
  def timeout; end
  def timeout=(_arg0); end

  protected

  def initialize_connection(connection); end
end

class Thin::Backends::SwiftiplyClient < ::Thin::Backends::Base
  def initialize(host, port, options = T.unsafe(nil)); end

  def connect; end
  def disconnect; end
  def host; end
  def host=(_arg0); end
  def key; end
  def key=(_arg0); end
  def port; end
  def port=(_arg0); end
  def to_s; end
end

class Thin::Backends::TcpServer < ::Thin::Backends::Base
  def initialize(host, port); end

  def connect; end
  def disconnect; end
  def host; end
  def host=(_arg0); end
  def port; end
  def port=(_arg0); end
  def to_s; end
end

class Thin::Backends::UnixServer < ::Thin::Backends::Base
  def initialize(socket); end

  def close; end
  def connect; end
  def disconnect; end
  def socket; end
  def socket=(_arg0); end
  def to_s; end

  protected

  def remove_socket_file; end
end

class Thin::Command
  include ::Thin::Logging

  def initialize(name, options = T.unsafe(nil)); end

  def run; end
  def shellify; end

  class << self
    def run(*args); end
    def script; end
    def script=(_arg0); end
  end
end

class Thin::Connection < ::EventMachine::Connection
  include ::Thin::Logging

  def app; end
  def app=(_arg0); end
  def backend; end
  def backend=(_arg0); end
  def can_persist!; end
  def can_persist?; end
  def close_request_response; end
  def idle?; end
  def persistent?; end
  def post_init; end
  def post_process(result); end
  def pre_process; end
  def process; end
  def receive_data(data); end
  def remote_address; end
  def request; end
  def request=(_arg0); end
  def response; end
  def response=(_arg0); end
  def ssl_verify_peer(cert); end
  def terminate_request; end
  def threaded=(_arg0); end
  def threaded?; end
  def unbind; end
  def unexpected_error(e); end

  protected

  def socket_address; end
end

Thin::Connection::AsyncResponse = T.let(T.unsafe(nil), Array)
module Thin::Controllers; end

class Thin::Controllers::Cluster < ::Thin::Controllers::Controller
  def initialize(options); end

  def address; end
  def first_port; end
  def log_file; end
  def log_file_for(number); end
  def onebyone; end
  def only; end
  def pid_file; end
  def pid_file_for(number); end
  def pid_for(number); end
  def restart; end
  def server_id(number); end
  def size; end
  def socket; end
  def socket_for(number); end
  def start; end
  def start_server(number); end
  def stop; end
  def stop_server(number); end
  def swiftiply?; end
  def test_socket(number); end
  def wait; end
  def wait_until_server_started(number); end

  private

  def include_server_number(path, number); end
  def run(cmd, number); end
  def with_each_server; end
end

Thin::Controllers::Cluster::CLUSTER_OPTIONS = T.let(T.unsafe(nil), Array)
Thin::Controllers::Cluster::DEFAULT_WAIT_TIME = T.let(T.unsafe(nil), Integer)

class Thin::Controllers::Controller
  include ::Thin::Logging

  def initialize(options); end

  def config; end
  def options; end
  def options=(_arg0); end
  def restart; end
  def start; end
  def stop; end

  protected

  def tail(file); end
  def tail_log(log_file); end
  def wait_for_file(state, file); end

  private

  def load_adapter; end
  def load_rackup_config; end
end

class Thin::Controllers::Service < ::Thin::Controllers::Controller
  def initialize(options); end

  def config_path; end
  def install(config_files_path = T.unsafe(nil)); end
  def restart; end
  def start; end
  def stop; end

  private

  def run(command); end
  def sh(cmd); end
end

Thin::Controllers::Service::DEFAULT_CONFIG_PATH = T.let(T.unsafe(nil), String)
Thin::Controllers::Service::INITD_PATH = T.let(T.unsafe(nil), String)
Thin::Controllers::Service::TEMPLATE = T.let(T.unsafe(nil), String)

module Thin::Daemonizable
  mixes_in_class_methods ::Thin::Daemonizable::ClassMethods

  def change_privilege(user, group = T.unsafe(nil)); end
  def daemonize; end
  def kill(timeout = T.unsafe(nil)); end
  def log_file; end
  def log_file=(_arg0); end
  def on_restart(&block); end
  def pid; end
  def pid_file; end
  def pid_file=(_arg0); end
  def restart; end

  protected

  def remove_pid_file; end
  def remove_stale_pid_file; end
  def write_pid_file; end

  class << self
    def included(base); end
  end
end

module Thin::Daemonizable::ClassMethods
  def force_kill(pid, pid_file); end
  def kill(pid_file, timeout = T.unsafe(nil)); end
  def monotonic_time; end
  def read_pid_file(file); end
  def restart(pid_file); end
  def send_signal(signal, pid_file, timeout = T.unsafe(nil)); end
end

Thin::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

class Thin::Headers
  def initialize; end

  def []=(key, value); end
  def has_key?(key); end
  def to_s; end
end

Thin::Headers::ALLOWED_DUPLICATES = T.let(T.unsafe(nil), Array)
Thin::Headers::CR_OR_LF = T.let(T.unsafe(nil), Regexp)
Thin::Headers::HEADER_FORMAT = T.let(T.unsafe(nil), String)

class Thin::HttpParser
  def initialize; end

  def error?; end
  def execute(_arg0, _arg1, _arg2); end
  def finish; end
  def finished?; end
  def nread; end
  def reset; end
end

class Thin::InvalidHeader < ::StandardError; end
class Thin::InvalidOption < ::Thin::RunnerError; end
class Thin::InvalidRequest < ::IOError; end

module Thin::Logging
  def log(msg); end
  def log_debug(msg = T.unsafe(nil)); end
  def log_error(msg, e = T.unsafe(nil)); end
  def log_info(msg); end
  def silent; end
  def silent=(value); end
  def trace(msg = T.unsafe(nil)); end

  class << self
    def debug=(val); end
    def debug?; end
    def level; end
    def level=(value); end
    def log_debug(msg = T.unsafe(nil)); end
    def log_error(msg, e = T.unsafe(nil)); end
    def log_info(msg); end
    def log_msg(msg, level = T.unsafe(nil)); end
    def logger; end
    def logger=(custom_logger); end
    def silent=(shh); end
    def silent?; end
    def trace(msg = T.unsafe(nil)); end
    def trace=(enabled); end
    def trace?; end
    def trace_logger; end
    def trace_logger=(custom_tracer); end
    def trace_msg(msg); end
  end
end

class Thin::Logging::SimpleFormatter < ::Logger::Formatter
  def call(severity, timestamp, progname, msg); end
end

Thin::NAME = T.let(T.unsafe(nil), String)

class Thin::OptionRequired < ::Thin::RunnerError
  def initialize(option); end
end

class Thin::PidFileExist < ::RuntimeError; end
class Thin::PidFileNotFound < ::RuntimeError; end
class Thin::PlatformNotSupported < ::RuntimeError; end

class Thin::Request
  def initialize; end

  def async_callback=(callback); end
  def async_close; end
  def body; end
  def close; end
  def content_length; end
  def data; end
  def env; end
  def finished?; end
  def head?; end
  def parse(data); end
  def persistent?; end
  def remote_address=(address); end
  def threaded=(value); end

  private

  def move_body_to_tempfile; end
end

Thin::Request::ASYNC_CALLBACK = T.let(T.unsafe(nil), String)
Thin::Request::ASYNC_CLOSE = T.let(T.unsafe(nil), String)
Thin::Request::BODY_TMPFILE = T.let(T.unsafe(nil), String)
Thin::Request::CLOSE_REGEXP = T.let(T.unsafe(nil), Regexp)
Thin::Request::CONNECTION = T.let(T.unsafe(nil), String)
Thin::Request::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Thin::Request::HEAD = T.let(T.unsafe(nil), String)
Thin::Request::HTTP_1_0 = T.let(T.unsafe(nil), String)
Thin::Request::HTTP_VERSION = T.let(T.unsafe(nil), String)
Thin::Request::INITIAL_BODY = T.let(T.unsafe(nil), String)
Thin::Request::KEEP_ALIVE_REGEXP = T.let(T.unsafe(nil), Regexp)
Thin::Request::LOCALHOST = T.let(T.unsafe(nil), String)
Thin::Request::MAX_BODY = T.let(T.unsafe(nil), Integer)
Thin::Request::MAX_HEADER = T.let(T.unsafe(nil), Integer)
Thin::Request::RACK_ERRORS = T.let(T.unsafe(nil), String)
Thin::Request::RACK_INPUT = T.let(T.unsafe(nil), String)
Thin::Request::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)
Thin::Request::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)
Thin::Request::RACK_RUN_ONCE = T.let(T.unsafe(nil), String)
Thin::Request::RACK_VERSION = T.let(T.unsafe(nil), String)
Thin::Request::REMOTE_ADDR = T.let(T.unsafe(nil), String)
Thin::Request::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Thin::Request::SERVER_NAME = T.let(T.unsafe(nil), String)
Thin::Request::SERVER_SOFTWARE = T.let(T.unsafe(nil), String)

class Thin::Response
  def initialize; end

  def body; end
  def body=(_arg0); end
  def close; end
  def each; end
  def head; end
  def headers; end
  def headers=(key_value_pairs); end
  def headers_output; end
  def persistent!; end
  def persistent?; end
  def skip_body!; end
  def status; end
  def status=(_arg0); end
end

Thin::Response::BAD_REQUEST = T.let(T.unsafe(nil), Array)
Thin::Response::CLOSE = T.let(T.unsafe(nil), String)
Thin::Response::CONNECTION = T.let(T.unsafe(nil), String)
Thin::Response::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Thin::Response::ERROR = T.let(T.unsafe(nil), Array)
Thin::Response::KEEP_ALIVE = T.let(T.unsafe(nil), String)
Thin::Response::PERSISTENT_ERROR = T.let(T.unsafe(nil), Array)
Thin::Response::PERSISTENT_STATUSES = T.let(T.unsafe(nil), Array)
Thin::Response::SERVER = T.let(T.unsafe(nil), String)
class Thin::RestartTimeout < ::RuntimeError; end

class Thin::Runner
  def initialize(argv); end

  def arguments; end
  def arguments=(_arg0); end
  def cluster?; end
  def command; end
  def command=(_arg0); end
  def options; end
  def options=(_arg0); end
  def parse!; end
  def parser; end
  def run!; end
  def run_command; end
  def service?; end

  private

  def load_options_from_config_file!; end
  def ruby_require(file); end

  class << self
    def commands; end
  end
end

Thin::Runner::COMMANDS = T.let(T.unsafe(nil), Array)
Thin::Runner::CONFIGLESS_COMMANDS = T.let(T.unsafe(nil), Array)
Thin::Runner::LINUX_ONLY_COMMANDS = T.let(T.unsafe(nil), Array)
class Thin::RunnerError < ::RuntimeError; end
Thin::SERVER = T.let(T.unsafe(nil), String)

class Thin::Server
  include ::Thin::Logging
  include ::Thin::Daemonizable
  extend ::Thin::Daemonizable::ClassMethods
  extend ::Forwardable

  def initialize(*args, &block); end

  def app; end
  def app=(_arg0); end
  def backend; end
  def backend=(_arg0); end
  def config; end
  def host(*args, &block); end
  def maximum_connections(*args, &block); end
  def maximum_connections=(*args, &block); end
  def maximum_persistent_connections(*args, &block); end
  def maximum_persistent_connections=(*args, &block); end
  def name; end
  def no_epoll(*args, &block); end
  def no_epoll=(*args, &block); end
  def port(*args, &block); end
  def reopen_log; end
  def running?; end
  def socket(*args, &block); end
  def ssl=(*args, &block); end
  def ssl?(*args, &block); end
  def ssl_options=(*args, &block); end
  def start; end
  def start!; end
  def stop; end
  def stop!; end
  def tag; end
  def tag=(_arg0); end
  def threaded=(*args, &block); end
  def threaded?(*args, &block); end
  def threadpool_size(*args, &block); end
  def threadpool_size=(*args, &block); end
  def timeout(*args, &block); end
  def timeout=(*args, &block); end
  def to_s; end

  protected

  def handle_signals; end
  def load_cgi_multipart_eof_fix; end
  def select_backend(host, port, options); end
  def setup_signals; end

  class << self
    def start(*args, &block); end
  end
end

Thin::Server::DEFAULT_HOST = T.let(T.unsafe(nil), String)
Thin::Server::DEFAULT_MAXIMUM_CONNECTIONS = T.let(T.unsafe(nil), Integer)
Thin::Server::DEFAULT_MAXIMUM_PERSISTENT_CONNECTIONS = T.let(T.unsafe(nil), Integer)
Thin::Server::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
Thin::Server::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)
module Thin::Stats; end

class Thin::Stats::Adapter
  include ::ERB::Util

  def initialize(app, path = T.unsafe(nil)); end

  def call(env); end
  def log(env); end
  def serve(env); end
end

class Thin::SwiftiplyConnection < ::Thin::Connection
  def connection_completed; end
  def persistent?; end
  def unbind; end

  protected

  def host_ip; end
  def swiftiply_handshake(key); end
end

class Thin::UnixConnection < ::Thin::Connection
  protected

  def socket_address; end
end

module Thin::VERSION; end
Thin::VERSION::CODENAME = T.let(T.unsafe(nil), String)
Thin::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)
Thin::VERSION::MINOR = T.let(T.unsafe(nil), Integer)
Thin::VERSION::RACK = T.let(T.unsafe(nil), Array)
Thin::VERSION::STRING = T.let(T.unsafe(nil), String)
Thin::VERSION::TINY = T.let(T.unsafe(nil), Integer)
