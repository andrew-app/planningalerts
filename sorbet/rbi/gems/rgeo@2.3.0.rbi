# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rgeo` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module RGeo; end

module RGeo::Cartesian
  class << self
    def factory(opts = T.unsafe(nil)); end
    def factory_generator(defaults = T.unsafe(nil)); end
    def preferred_factory(opts = T.unsafe(nil)); end
    def preferred_factory_generator(defaults = T.unsafe(nil)); end
    def simple_factory(opts = T.unsafe(nil)); end
    def simple_factory_generator(defaults = T.unsafe(nil)); end
  end
end

module RGeo::Cartesian::Analysis
  class << self
    def ccw?(ring); end
    def counter_clockwise?(ring); end
    def ring_direction(ring); end
  end
end

class RGeo::Cartesian::BoundingBox
  def initialize(factory, opts = T.unsafe(nil)); end

  def ==(rhs); end
  def add(geometry); end
  def add_geometry(geometry); end
  def center_m; end
  def center_x; end
  def center_y; end
  def center_z; end
  def contains?(rhs, opts = T.unsafe(nil)); end
  def degenerate?; end
  def empty?; end
  def eql?(rhs); end
  def factory; end
  def has_m; end
  def has_z; end
  def infinitesimal?; end
  def m_span; end
  def max_m; end
  def max_point; end
  def max_x; end
  def max_y; end
  def max_z; end
  def min_m; end
  def min_point; end
  def min_x; end
  def min_y; end
  def min_z; end
  def subdivide(opts = T.unsafe(nil)); end
  def to_geometry; end
  def x_span; end
  def y_span; end
  def z_span; end

  private

  def add_point(point); end

  class << self
    def create_from_geometry(geom, opts = T.unsafe(nil)); end
    def create_from_points(point1, point2, opts = T.unsafe(nil)); end
  end
end

class RGeo::Cartesian::Factory
  include ::RGeo::Feature::Factory::Instance
  include ::RGeo::ImplHelper::Utils

  def initialize(opts = T.unsafe(nil)); end

  def ==(rhs); end
  def collection(elems); end
  def coord_sys; end
  def encode_with(coder); end
  def eql?(rhs); end
  def generate_wkb(obj); end
  def generate_wkt(obj); end
  def hash; end
  def init_with(coder); end
  def line(start, stop); end
  def line_string(points); end
  def linear_ring(points); end
  def marshal_dump; end
  def marshal_load(data); end
  def marshal_wkb_generator; end
  def marshal_wkb_parser; end
  def multi_line_string(elems); end
  def multi_point(elems); end
  def multi_polygon(elems); end
  def parse_wkb(str); end
  def parse_wkt(str); end
  def point(x, y, *extra); end
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end
  def proj4; end
  def property(name); end
  def psych_wkt_generator; end
  def psych_wkt_parser; end
  def srid; end
end

class RGeo::Cartesian::GeometryCollectionImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::Cartesian::GeometryMethods
end

module RGeo::Cartesian::GeometryMethods
  def envelope; end
  def srid; end
end

class RGeo::Cartesian::LineImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Line
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLineMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::LineStringMethods
end

class RGeo::Cartesian::LineStringImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::LineStringMethods
end

module RGeo::Cartesian::LineStringMethods
  def is_simple?; end
  def length; end
  def segments; end
end

class RGeo::Cartesian::LinearRingImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::LinearRing
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLinearRingMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::LineStringMethods
end

class RGeo::Cartesian::MultiLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  include ::RGeo::Feature::MultiLineString
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiLineStringMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::MultiLineStringMethods
end

module RGeo::Cartesian::MultiLineStringMethods
  def length; end
end

class RGeo::Cartesian::MultiPointImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiPoint
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPointMethods
  include ::RGeo::Cartesian::GeometryMethods
end

class RGeo::Cartesian::MultiPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  include ::RGeo::Feature::MultiPolygon
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPolygonMethods
  include ::RGeo::Cartesian::GeometryMethods
end

class RGeo::Cartesian::PointImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Point
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPointMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::PointMethods
end

module RGeo::Cartesian::PointMethods
  def buffer(distance); end
  def distance(rhs); end
end

class RGeo::Cartesian::PolygonImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  include ::RGeo::Feature::Polygon
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPolygonMethods
  include ::RGeo::Cartesian::GeometryMethods
end

class RGeo::Cartesian::Segment
  def initialize(start, stop); end

  def ==(rhs); end
  def contains_point?(p); end
  def degenerate?; end
  def dx; end
  def dy; end
  def e; end
  def eql?(rhs); end
  def intersects_segment?(seg); end
  def length; end
  def s; end
  def side(p); end
  def to_s; end
  def tproj(p); end
end

module RGeo::CoordSys
  class << self
    def check!(key); end
    def supported?(key); end
  end
end

module RGeo::CoordSys::CS
  class << self
    def create_from_wkt(str); end
  end
end

RGeo::CoordSys::CS::AO_DOWN = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::AO_EAST = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::AO_NORTH = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::AO_OTHER = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::AO_SOUTH = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::AO_UP = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::AO_WEST = T.let(T.unsafe(nil), Integer)

class RGeo::CoordSys::CS::AngularUnit < ::RGeo::CoordSys::CS::Unit
  def radians_per_unit; end

  class << self
    def create(name, radians_per_unit, *optional); end
  end
end

class RGeo::CoordSys::CS::AxisInfo < ::RGeo::CoordSys::CS::Base
  def initialize(name, orientation); end

  def name; end
  def orientation; end
  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    def create(name, orientation); end
  end
end

RGeo::CoordSys::CS::AxisInfo::NAMES_BY_VALUE = T.let(T.unsafe(nil), Array)

class RGeo::CoordSys::CS::Base
  def ==(rhs); end
  def encode_with(coder); end
  def eql?(rhs); end
  def hash; end
  def init_with(coder); end
  def inspect; end
  def marshal_dump; end
  def marshal_load(data); end
  def to_s; end
  def to_wkt(standard_brackets = T.unsafe(nil)); end

  private

  def brackets(standard); end
end

class RGeo::CoordSys::CS::CompoundCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  def initialize(name, head, tail, *optional); end

  def get_axis(index); end
  def get_units(index); end
  def head; end
  def tail; end
  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    def create(name, head, tail, *optional); end
  end
end

class RGeo::CoordSys::CS::CoordinateSystem < ::RGeo::CoordSys::CS::Info
  def initialize(name, dimension, *optional); end

  def dimension; end
  def get_axis(dimension); end
  def get_units(dimension); end
end

class RGeo::CoordSys::CS::CoordinateSystemFactory
  def create_compound_coordinate_system(name, head, tail); end
  def create_ellipsoid(name, semi_major_axis, semi_minor_axis, linear_unit); end
  def create_flattened_sphere(name, semi_major_axis, inverse_flattening, linear_unit); end
  def create_from_wkt(str); end
  def create_geographic_coordinate_system(name, angular_unit, horizontal_datum, prime_meridian, axis0, axis1); end
  def create_horizontal_datum(name, horizontal_datum_type, ellipsoid, to_wgs84); end
  def create_local_coordinate_system(name, datum, unit, axes); end
  def create_local_datum(_name, local_datum_type); end
  def create_prime_meridian(_name, angular_unit, longitude); end
  def create_projected_coordinate_system(name, gcs, projection, linear_unit, axis0, axis1); end
  def create_projection(name, wkt_projection_class, parameters); end
  def create_vertical_coordinate_system(name, vertical_datum, vertical_unit, axis); end
  def create_vertical_datum(name, vertical_datum_type); end
end

class RGeo::CoordSys::CS::Datum < ::RGeo::CoordSys::CS::Info
  def initialize(name, datum_type, *optional); end

  def datum_type; end

  private

  def wkt_content(_); end
end

class RGeo::CoordSys::CS::Ellipsoid < ::RGeo::CoordSys::CS::Info
  def initialize(name, semi_major_axis, semi_minor_axis, inverse_flattening, ivf_definitive, linear_unit, *optional); end

  def axisunit; end
  def inverse_flattening; end
  def ivf_definitive; end
  def semi_major_axis; end
  def semi_minor_axis; end
  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    def create(name, semi_major_axis, semi_minor_axis, inverse_flattening, ivf_definitive, linear_unit, *optional); end
    def create_ellipsoid(name, semi_major_axis, semi_minor_axis, linear_unit, *optional); end
    def create_flattened_sphere(name, semi_major_axis, inverse_flattening, linear_unit, *optional); end
  end
end

class RGeo::CoordSys::CS::GeocentricCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  def initialize(name, horizontal_datum, prime_meridian, linear_unit, axis0, axis1, axis2, *optional); end

  def get_axis(index); end
  def get_units(index); end
  def horizontal_datum; end
  def linear_unit; end
  def prime_meridian; end
  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    def create(name, horizontal_datum, prime_meridian, linear_unit, axis0, axis1, axis2, *optional); end
  end
end

class RGeo::CoordSys::CS::GeographicCoordinateSystem < ::RGeo::CoordSys::CS::HorizontalCoordinateSystem
  def initialize(name, angular_unit, horizontal_datum, prime_meridian, axis0, axis1, *optional); end

  def angular_unit; end
  def get_axis(index); end
  def get_units(index); end
  def get_wgs84_conversion_info(index); end
  def num_conversion_to_wgs84; end
  def prime_meridian; end
  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    def create(name, angular_unit, horizontal_datum, prime_meridian, axis0, axis1, *optional); end
  end
end

RGeo::CoordSys::CS::HD_CLASSIC = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::HD_GEOCENTRIC = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::HD_MAX = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::HD_MIN = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::HD_OTHER = T.let(T.unsafe(nil), Integer)

class RGeo::CoordSys::CS::HorizontalCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  def initialize(name, horizontal_datum, *optional); end

  def horizontal_datum; end
end

class RGeo::CoordSys::CS::HorizontalDatum < ::RGeo::CoordSys::CS::Datum
  def initialize(name, datum_type, ellipsoid, wgs84_parameters, *optional); end

  def ellipsoid; end
  def wgs84_parameters; end
  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    def create(name, datum_type, ellipsoid, wgs84_parameters, *optional); end
  end
end

class RGeo::CoordSys::CS::Info < ::RGeo::CoordSys::CS::Base
  def initialize(name, authority = T.unsafe(nil), authority_code = T.unsafe(nil), abbreviation = T.unsafe(nil), init_alias = T.unsafe(nil), remarks = T.unsafe(nil), extensions = T.unsafe(nil)); end

  def abbreviation; end
  def alias; end
  def authority; end
  def authority_code; end
  def extension(key); end
  def name; end
  def remarks; end
end

RGeo::CoordSys::CS::LD_MAX = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::LD_MIN = T.let(T.unsafe(nil), Integer)

class RGeo::CoordSys::CS::LinearUnit < ::RGeo::CoordSys::CS::Unit
  def meters_per_unit; end

  class << self
    def create(name, meters_per_unit, *optional); end
  end
end

class RGeo::CoordSys::CS::LocalCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  def initialize(name, local_datum, unit, axes, *optional); end

  def get_axis(index); end
  def get_units(index); end
  def local_datum; end
  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    def create(name, local_datum, unit, axes, *optional); end
  end
end

class RGeo::CoordSys::CS::LocalDatum < ::RGeo::CoordSys::CS::Datum
  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    def create(name, datum_type, *optional); end
  end
end

class RGeo::CoordSys::CS::PrimeMeridian < ::RGeo::CoordSys::CS::Info
  def initialize(name, angular_unit, longitude, *optional); end

  def angular_unit; end
  def longitude; end
  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    def create(name, angular_unit, longitude, *optional); end
  end
end

class RGeo::CoordSys::CS::ProjectedCoordinateSystem < ::RGeo::CoordSys::CS::HorizontalCoordinateSystem
  def initialize(name, geographic_coordinate_system, projection, linear_unit, axis0, axis1, *optional); end

  def geographic_coordinate_system; end
  def get_axis(index); end
  def get_units(index); end
  def linear_unit; end
  def projection; end
  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    def create(name, geographic_coordinate_system, projection, linear_unit, axis0, axis1, *optional); end
  end
end

class RGeo::CoordSys::CS::Projection < ::RGeo::CoordSys::CS::Info
  def initialize(name, class_name, parameters, *optional); end

  def class_name; end
  def each_parameter(&block); end
  def get_parameter(index); end
  def num_parameters; end
  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    def create(name, class_name, parameters, *optional); end
  end
end

class RGeo::CoordSys::CS::ProjectionParameter < ::RGeo::CoordSys::CS::Base
  def initialize(name, value); end

  def name; end
  def value; end
  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    def create(name, value); end
  end
end

class RGeo::CoordSys::CS::Unit < ::RGeo::CoordSys::CS::Info
  def initialize(name, conversion_factor, *optional); end

  def conversion_factor; end
  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    def create(name, conversion_factor, *optional); end
  end
end

RGeo::CoordSys::CS::VD_ALTITUDE_BAROMETRIC = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::VD_DEPTH = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::VD_ELLIPSOIDAL = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::VD_GEOID_MODE_DERIVED = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::VD_MAX = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::VD_MIN = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::VD_NORMAL = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::VD_ORTHOMETRIC = T.let(T.unsafe(nil), Integer)
RGeo::CoordSys::CS::VD_OTHER = T.let(T.unsafe(nil), Integer)

class RGeo::CoordSys::CS::VerticalCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  def initialize(name, vertical_datum, vertical_unit, axis, *optional); end

  def get_axis(index); end
  def get_units(index); end
  def vertical_datum; end
  def vertical_unit; end
  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    def create(name, vertical_datum, vertical_unit, axis, *optional); end
  end
end

class RGeo::CoordSys::CS::VerticalDatum < ::RGeo::CoordSys::CS::Datum
  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    def create(name, datum_type, *optional); end
  end
end

class RGeo::CoordSys::CS::WGS84ConversionInfo < ::RGeo::CoordSys::CS::Base
  def initialize(dx, dy, dz, ex, ey, ez, ppm); end

  def dx; end
  def dy; end
  def dz; end
  def ex; end
  def ey; end
  def ez; end
  def ppm; end
  def to_wkt(standard_brackets = T.unsafe(nil)); end

  class << self
    def create(dx, dy, dz, ex, ey, ez, ppm); end
  end
end

class RGeo::CoordSys::CS::WKTParser
  def initialize(str); end

  def consume_tokentype(type); end
  def cur_token; end
  def expect_tokentype(type); end
  def next_token; end
  def parse(containing_type = T.unsafe(nil)); end
end

class RGeo::CoordSys::CS::WKTParser::ArgumentList
  def initialize; end

  def <<(value); end
  def assert_empty; end
  def create_optionals; end
  def find_all(klass); end
  def find_first(klass); end
  def shift(klass = T.unsafe(nil)); end
end

class RGeo::CoordSys::CS::WKTParser::AuthorityClause
  def initialize(name, code); end

  def to_a; end
end

class RGeo::CoordSys::CS::WKTParser::ExtensionClause
  def initialize(key, value); end

  def key; end
  def value; end
end

class RGeo::CoordSys::CS::WKTParser::QuotedString < ::String; end
class RGeo::CoordSys::CS::WKTParser::TypeString < ::String; end
module RGeo::CoordSys::SRSDatabase; end

class RGeo::CoordSys::SRSDatabase::Entry
  def initialize(ident, data = T.unsafe(nil)); end

  def authority; end
  def authority_code; end
  def coord_sys; end
  def description; end
  def identifier; end
  def name; end
  def proj4; end
end

class RGeo::CoordSys::SRSDatabase::SrOrg
  def initialize(catalog, opts = T.unsafe(nil)); end

  def catalog; end
  def clear_cache; end
  def get(ident); end
end

class RGeo::CoordSys::SRSDatabase::UrlReader
  def initialize(opts = T.unsafe(nil)); end

  def clear_cache; end
  def get(ident); end
end

module RGeo::Error; end
class RGeo::Error::GeosError < ::RGeo::Error::RGeoError; end
class RGeo::Error::InvalidGeometry < ::RGeo::Error::RGeoError; end
class RGeo::Error::ParseError < ::RGeo::Error::RGeoError; end
class RGeo::Error::RGeoError < ::RuntimeError; end
class RGeo::Error::UnsupportedOperation < ::RGeo::Error::RGeoError; end

module RGeo::Feature
  class << self
    def cast(obj, *params); end
  end
end

module RGeo::Feature::Curve
  include ::RGeo::Feature::Geometry
  extend ::RGeo::Feature::Type

  def end_point; end
  def is_closed?; end
  def is_ring?; end
  def length; end
  def start_point; end
end

module RGeo::Feature::Factory
  def collection(elems); end
  def coord_sys; end
  def line(start, stop); end
  def line_string(points); end
  def linear_ring(points); end
  def multi_line_string(elems); end
  def multi_point(elems); end
  def multi_polygon(elems); end
  def override_cast(original, type, flags); end
  def parse_wkb(str); end
  def parse_wkt(str); end
  def point(x, y, *extra); end
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end
  def proj4; end
  def property(name); end
end

module RGeo::Feature::Factory::Instance; end

module RGeo::Feature::FactoryGenerator
  def call(config = T.unsafe(nil)); end

  class << self
    def decorate(delegate, default_config = T.unsafe(nil), force_config = T.unsafe(nil)); end
    def single(factory); end
  end
end

module RGeo::Feature::Geometry
  extend ::RGeo::Feature::Type

  def *(rhs); end
  def +(rhs); end
  def -(rhs); end
  def ==(rhs); end
  def as_binary; end
  def as_text; end
  def boundary; end
  def buffer(_distance_); end
  def contains?(another_geometry); end
  def convex_hull; end
  def crosses?(another_geometry); end
  def difference(another_geometry); end
  def dimension; end
  def disjoint?(another_geometry); end
  def distance(another_geometry); end
  def envelope; end
  def eql?(rhs); end
  def equals?(another_geometry); end
  def factory; end
  def geometry_type; end
  def intersection(another_geometry); end
  def intersects?(another_geometry); end
  def is_empty?; end
  def is_simple?; end
  def overlaps?(another_geometry); end
  def relate?(another_geometry, _intersection_pattern_matrix_); end
  def rep_equals?(another_geometry); end
  def srid; end
  def sym_difference(another_geometry); end
  def touches?(another_geometry); end
  def unary_union; end
  def union(another_geometry); end
  def within?(another_geometry); end
end

module RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  extend ::RGeo::Feature::Type

  def [](n); end
  def each(&block); end
  def geometry_n(n); end
  def node; end
  def num_geometries; end
  def size; end
end

module RGeo::Feature::Instance; end

module RGeo::Feature::Line
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  extend ::RGeo::Feature::Type
end

module RGeo::Feature::LineString
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  extend ::RGeo::Feature::Type

  def num_points; end
  def point_n(n); end
  def points; end
end

module RGeo::Feature::LinearRing
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  extend ::RGeo::Feature::Type

  def ccw?; end
end

module RGeo::Feature::MultiCurve
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  extend ::RGeo::Feature::Type

  def is_closed?; end
  def length; end
end

module RGeo::Feature::MultiLineString
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  extend ::RGeo::Feature::Type
end

module RGeo::Feature::MultiPoint
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  extend ::RGeo::Feature::Type
end

module RGeo::Feature::MultiPolygon
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  extend ::RGeo::Feature::Type
end

module RGeo::Feature::MultiSurface
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  extend ::RGeo::Feature::Type

  def area; end
  def centroid; end
  def point_on_surface; end
end

module RGeo::Feature::Point
  include ::RGeo::Feature::Geometry
  extend ::RGeo::Feature::Type

  def m; end
  def x; end
  def y; end
  def z; end
end

module RGeo::Feature::Polygon
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  extend ::RGeo::Feature::Type

  def exterior_ring; end
  def interior_ring_n(n); end
  def interior_rings; end
  def num_interior_rings; end
end

module RGeo::Feature::Surface
  include ::RGeo::Feature::Geometry
  extend ::RGeo::Feature::Type

  def area; end
  def centroid; end
  def point_on_surface; end
end

module RGeo::Feature::Type
  def ===(rhs); end
  def add_subtype(type); end
  def check_type(rhs); end
  def each_immediate_subtype(&block); end
  def subtype_of?(type); end
  def supertype; end
  def to_s; end
  def type_name; end

  class << self
    def extended(type); end
  end
end

module RGeo::Geographic
  class << self
    def projected_factory(opts = T.unsafe(nil)); end
    def simple_mercator_factory(opts = T.unsafe(nil)); end
    def spherical_factory(opts = T.unsafe(nil)); end

    private

    def coord_sys_4055; end
    def coord_sys_4326; end
    def proj_4055; end
    def proj_4326; end
  end
end

class RGeo::Geographic::Factory
  include ::RGeo::Feature::Factory::Instance
  include ::RGeo::ImplHelper::Utils

  def initialize(impl_prefix, opts = T.unsafe(nil)); end

  def ==(rhs_); end
  def collection(elems); end
  def coord_sys; end
  def encode_with(coder); end
  def eql?(rhs_); end
  def generate_wkb(obj); end
  def generate_wkt(obj); end
  def has_projection?; end
  def hash; end
  def init_with(coder); end
  def line(start, stop); end
  def line_string(points); end
  def linear_ring(points); end
  def marshal_dump; end
  def marshal_load(data_); end
  def marshal_wkb_generator; end
  def marshal_wkb_parser; end
  def multi_line_string(elems); end
  def multi_point(elems); end
  def multi_polygon(elems); end
  def parse_wkb(str); end
  def parse_wkt(str); end
  def point(x, y, *extra); end
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end
  def proj4; end
  def project(geometry); end
  def projection_factory; end
  def projection_limits_window; end
  def projection_wraps?; end
  def projector=(_arg0); end
  def property(name); end
  def psych_wkt_generator; end
  def psych_wkt_parser; end
  def srid; end
  def unproject(geometry); end
end

class RGeo::Geographic::Proj4Projector
  def initialize(geography_factory, projection_factory); end

  def limits_window; end
  def project(geometry); end
  def projection_factory; end
  def set_factories(geography_factory, projection_factory); end
  def unproject(geometry); end
  def wraps?; end

  class << self
    def create_from_existing_factory(geography_factory, projection_factory); end
    def create_from_proj4(geography_factory, proj4, opts = T.unsafe(nil)); end
  end
end

class RGeo::Geographic::ProjectedGeometryCollectionImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
end

module RGeo::Geographic::ProjectedGeometryMethods
  def boundary; end
  def buffer(distance); end
  def buffer_with_style(distance, end_cap_style, join_style, mitre_limit); end
  def contains?(rhs); end
  def convex_hull; end
  def crosses?(rhs); end
  def difference(rhs); end
  def disjoint?(rhs); end
  def distance(rhs); end
  def envelope; end
  def equals?(rhs); end
  def intersection(rhs); end
  def intersects?(rhs); end
  def is_empty?; end
  def is_simple?; end
  def overlaps?(rhs); end
  def point_on_surface; end
  def projection; end
  def relate(rhs, pattern_); end
  def simplify(tolerance); end
  def simplify_preserve_topology(tolerance); end
  def srid; end
  def sym_difference(rhs); end
  def touches?(rhs); end
  def union(rhs); end
  def within?(rhs); end
end

class RGeo::Geographic::ProjectedLineImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Line
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLineMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNCurveMethods
  include ::RGeo::Geographic::ProjectedLineStringMethods
end

class RGeo::Geographic::ProjectedLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNCurveMethods
  include ::RGeo::Geographic::ProjectedLineStringMethods
end

module RGeo::Geographic::ProjectedLineStringMethods
  private

  def validate_geometry; end
end

class RGeo::Geographic::ProjectedLinearRingImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::LinearRing
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLinearRingMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNCurveMethods
  include ::RGeo::Geographic::ProjectedLineStringMethods
end

class RGeo::Geographic::ProjectedMultiLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  include ::RGeo::Feature::MultiLineString
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiLineStringMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNCurveMethods
end

class RGeo::Geographic::ProjectedMultiPointImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiPoint
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPointMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
end

class RGeo::Geographic::ProjectedMultiPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  include ::RGeo::Feature::MultiPolygon
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPolygonMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNSurfaceMethods
  include ::RGeo::Geographic::ProjectedMultiPolygonMethods
end

module RGeo::Geographic::ProjectedMultiPolygonMethods
  private

  def validate_geometry; end
end

module RGeo::Geographic::ProjectedNCurveMethods
  def length; end
end

module RGeo::Geographic::ProjectedNSurfaceMethods
  def area; end
  def centroid; end
end

class RGeo::Geographic::ProjectedPointImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Point
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPointMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedPointMethods

  def lat; end
  def latitude; end
  def lon; end
  def longitude; end
end

module RGeo::Geographic::ProjectedPointMethods
  def canonical_lon; end
  def canonical_longitude; end
  def canonical_point; end
  def canonical_x; end

  private

  def validate_geometry; end

  class << self
    def included(klass); end
  end
end

class RGeo::Geographic::ProjectedPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  include ::RGeo::Feature::Polygon
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPolygonMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNSurfaceMethods
  include ::RGeo::Geographic::ProjectedPolygonMethods
end

module RGeo::Geographic::ProjectedPolygonMethods
  private

  def validate_geometry; end
end

class RGeo::Geographic::ProjectedWindow
  def initialize(factory_, x_min_, y_min_, x_max_, y_max_, opts_ = T.unsafe(nil)); end

  def *(x_factor_, y_factor_ = T.unsafe(nil)); end
  def ==(obj_); end
  def center_point; end
  def center_xy; end
  def clamped_by(min_width_, min_height_, max_width_, max_height_); end
  def contains_point?(point_); end
  def contains_window?(window_); end
  def crosses_seam?; end
  def degenerate?; end
  def eql?(obj_); end
  def factory; end
  def hash; end
  def height; end
  def inspect; end
  def ne_point; end
  def nw_point; end
  def random_point; end
  def scaled_by(x_factor_, y_factor_ = T.unsafe(nil)); end
  def se_point; end
  def sw_point; end
  def to_s; end
  def width; end
  def with_margin(x_margin_, y_margin_ = T.unsafe(nil)); end
  def x_max; end
  def x_min; end
  def x_span; end
  def y_max; end
  def y_min; end
  def y_span; end

  class << self
    def bounding_points(points_); end
    def for_corners(sw_, ne_); end
    def surrounding_point(point_, x_margin_ = T.unsafe(nil), y_margin_ = T.unsafe(nil)); end
  end
end

class RGeo::Geographic::SimpleMercatorProjector
  def initialize(geography_factory, opts = T.unsafe(nil)); end

  def limits_window; end
  def project(geometry); end
  def projection_factory; end
  def set_factories(geography_factory, projection_factory); end
  def unproject(geometry); end
  def wraps?; end

  class << self
    def _coordsys_3857; end
    def _proj4_3857; end
  end
end

RGeo::Geographic::SimpleMercatorProjector::EQUATORIAL_RADIUS = T.let(T.unsafe(nil), Float)

class RGeo::Geographic::SphericalGeometryCollectionImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
end

module RGeo::Geographic::SphericalGeometryMethods
  def srid; end
end

class RGeo::Geographic::SphericalLineImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Line
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLineMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalLineStringMethods
end

class RGeo::Geographic::SphericalLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalLineStringMethods
end

module RGeo::Geographic::SphericalLineStringMethods
  def arcs; end
  def is_simple?; end
  def length; end
end

class RGeo::Geographic::SphericalLinearRingImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::LinearRing
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLinearRingMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalLineStringMethods
end

module RGeo::Geographic::SphericalMath; end

class RGeo::Geographic::SphericalMath::ArcXYZ
  def initialize(start, stop); end

  def ==(rhs); end
  def axis; end
  def contains_point?(obj); end
  def degenerate?; end
  def e; end
  def eql?(rhs); end
  def intersects_arc?(obj); end
  def length; end
  def s; end
  def to_s; end
end

class RGeo::Geographic::SphericalMath::PointXYZ
  def initialize(x, y, z); end

  def %(rhs); end
  def *(rhs); end
  def ==(rhs); end
  def create_perpendicular; end
  def dist_to_point(rhs); end
  def eql?(rhs); end
  def latlon; end
  def lonlat; end
  def to_s; end
  def x; end
  def y; end
  def z; end

  class << self
    def from_latlon(lat, lon); end
    def weighted_combination(p1, w1, p2, w2); end
  end
end

RGeo::Geographic::SphericalMath::PointXYZ::P1 = T.let(T.unsafe(nil), RGeo::Geographic::SphericalMath::PointXYZ)
RGeo::Geographic::SphericalMath::PointXYZ::P2 = T.let(T.unsafe(nil), RGeo::Geographic::SphericalMath::PointXYZ)
RGeo::Geographic::SphericalMath::RADIUS = T.let(T.unsafe(nil), Float)

class RGeo::Geographic::SphericalMultiLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  include ::RGeo::Feature::MultiLineString
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiLineStringMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalMultiLineStringMethods
end

module RGeo::Geographic::SphericalMultiLineStringMethods
  def length; end
end

class RGeo::Geographic::SphericalMultiPointImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiPoint
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPointMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
end

class RGeo::Geographic::SphericalMultiPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  include ::RGeo::Feature::MultiPolygon
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPolygonMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
end

class RGeo::Geographic::SphericalPointImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Point
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPointMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalPointMethods

  def lat; end
  def latitude; end
  def lon; end
  def longitude; end
end

module RGeo::Geographic::SphericalPointMethods
  def buffer(distance); end
  def distance(rhs); end
  def equals?(rhs); end
  def xyz; end

  private

  def validate_geometry; end

  class << self
    def included(klass); end
  end
end

class RGeo::Geographic::SphericalPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  include ::RGeo::Feature::Polygon
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPolygonMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalPolygonMethods
end

module RGeo::Geographic::SphericalPolygonMethods
  def centroid; end
end

module RGeo::Geos
  class << self
    def capi_supported?; end
    def factory(opts = T.unsafe(nil)); end
    def factory_generator(defaults = T.unsafe(nil)); end
    def ffi_supported?; end
    def is_capi_geos?(object); end
    def is_ffi_geos?(object); end
    def is_geos?(object); end
    def preferred_native_interface; end
    def preferred_native_interface=(_arg0); end
    def supported?; end
    def version; end
  end
end

RGeo::Geos::CAP_FLAT = T.let(T.unsafe(nil), Integer)
RGeo::Geos::CAP_ROUND = T.let(T.unsafe(nil), Integer)
RGeo::Geos::CAP_SQUARE = T.let(T.unsafe(nil), Integer)

class RGeo::Geos::FFIFactory
  include ::RGeo::Feature::Factory::Instance
  include ::RGeo::ImplHelper::Utils

  def initialize(opts = T.unsafe(nil)); end

  def ==(rhs); end
  def _auto_prepare; end
  def _has_3d; end
  def buffer_resolution; end
  def collection(elems); end
  def convert_to_fg_geometry(obj, type = T.unsafe(nil)); end
  def coord_sys; end
  def encode_with(coder); end
  def eql?(rhs); end
  def generate_wkb(geom); end
  def generate_wkt(geom); end
  def hash; end
  def init_with(coder); end
  def inspect; end
  def lenient_multi_polygon_assertions?; end
  def line(start, stop); end
  def line_string(points); end
  def linear_ring(points); end
  def marshal_dump; end
  def marshal_load(data); end
  def multi_line_string(elems); end
  def multi_point(elems); end
  def multi_polygon(elems); end
  def override_cast(original, ntype, flags); end
  def parse_wkb(str); end
  def parse_wkt(str); end
  def point(x, y, z = T.unsafe(nil)); end
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end
  def proj4; end
  def property(name_); end
  def read_for_marshal(str); end
  def read_for_psych(str); end
  def srid; end
  def wrap_fg_geom(fg_geom, klass = T.unsafe(nil)); end
  def write_for_marshal(geom); end
  def write_for_psych(geom); end

  private

  def create_fg_linear_ring(points); end
end

class RGeo::Geos::FFIGeometryCollectionImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::FFIGeometryCollectionMethods
end

module RGeo::Geos::FFIGeometryCollectionMethods
  include ::Enumerable

  def [](n); end
  def each; end
  def geometry_n(n); end
  def geometry_type; end
  def hash; end
  def num_geometries; end
  def rep_equals?(rhs); end
  def size; end
end

class RGeo::Geos::FFIGeometryImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
end

module RGeo::Geos::FFIGeometryMethods
  include ::RGeo::Feature::Instance

  def initialize(factory, fg_geom, klasses); end

  def *(rhs); end
  def +(rhs); end
  def -(rhs); end
  def ==(rhs); end
  def _klasses; end
  def as_binary; end
  def as_text; end
  def boundary; end
  def buffer(distance); end
  def contains?(rhs); end
  def convex_hull; end
  def crosses?(rhs); end
  def detach_fg_geom; end
  def difference(rhs); end
  def dimension; end
  def disjoint?(rhs); end
  def distance(rhs); end
  def encode_with(coder); end
  def envelope; end
  def eql?(rhs); end
  def equals?(rhs); end
  def factory; end
  def fg_geom; end
  def geometry_type; end
  def init_with(coder); end
  def inspect; end
  def intersection(rhs); end
  def intersects?(rhs); end
  def is_empty?; end
  def is_simple?; end
  def marshal_dump; end
  def marshal_load(data); end
  def overlaps?(rhs); end
  def point_on_surface; end
  def prepare!; end
  def prepared?; end
  def relate(rhs, pattern); end
  def relate?(rhs, pattern); end
  def srid; end
  def sym_difference(rhs); end
  def to_s; end
  def touches?(rhs); end
  def unary_union; end
  def union(rhs); end
  def within?(rhs); end

  private

  def initialize_copy(orig); end
  def request_prepared; end
end

class RGeo::Geos::FFILineImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::RGeo::Geos::FFILineStringMethods
  include ::RGeo::Geos::FFILineMethods
end

module RGeo::Geos::FFILineMethods
  def geometry_type; end
end

class RGeo::Geos::FFILineStringImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::RGeo::Geos::FFILineStringMethods
end

module RGeo::Geos::FFILineStringMethods
  def coordinates; end
  def end_point; end
  def geometry_type; end
  def hash; end
  def is_closed?; end
  def is_ring?; end
  def length; end
  def num_points; end
  def point_n(n); end
  def points; end
  def rep_equals?(rhs); end
  def start_point; end
end

class RGeo::Geos::FFILinearRingImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::RGeo::Geos::FFILineStringMethods
  include ::RGeo::Geos::FFILinearRingMethods
end

module RGeo::Geos::FFILinearRingMethods
  def ccw?; end
  def geometry_type; end
end

class RGeo::Geos::FFIMultiLineStringImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::FFIGeometryCollectionMethods
  include ::RGeo::Geos::FFIMultiLineStringMethods
end

module RGeo::Geos::FFIMultiLineStringMethods
  def coordinates; end
  def geometry_type; end
  def is_closed?; end
  def length; end
end

class RGeo::Geos::FFIMultiPointImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::FFIGeometryCollectionMethods
  include ::RGeo::Geos::FFIMultiPointMethods
end

module RGeo::Geos::FFIMultiPointMethods
  def coordinates; end
  def geometry_type; end
end

class RGeo::Geos::FFIMultiPolygonImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::FFIGeometryCollectionMethods
  include ::RGeo::Geos::FFIMultiPolygonMethods
end

module RGeo::Geos::FFIMultiPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def geometry_type; end
end

class RGeo::Geos::FFIPointImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::RGeo::Geos::FFIPointMethods
end

module RGeo::Geos::FFIPointMethods
  def coordinates; end
  def geometry_type; end
  def hash; end
  def m; end
  def rep_equals?(rhs); end
  def x; end
  def y; end
  def z; end
end

class RGeo::Geos::FFIPolygonImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::RGeo::Geos::FFIPolygonMethods
end

module RGeo::Geos::FFIPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def exterior_ring; end
  def geometry_type; end
  def hash; end
  def interior_ring_n(n); end
  def interior_rings; end
  def num_interior_rings; end
  def point_on_surface; end
  def rep_equals?(rhs); end
end

RGeo::Geos::FFI_SUPPORT_EXCEPTION = T.let(T.unsafe(nil), LoadError)
RGeo::Geos::JOIN_BEVEL = T.let(T.unsafe(nil), Integer)
RGeo::Geos::JOIN_MITRE = T.let(T.unsafe(nil), Integer)
RGeo::Geos::JOIN_ROUND = T.let(T.unsafe(nil), Integer)

module RGeo::Geos::Utils
  class << self
    def ffi_compute_dimension(geom); end
    def ffi_coord_seq_hash(cs, hash = T.unsafe(nil)); end
    def ffi_coord_seqs_equal?(cs1, cs2, check_z); end
    def ffi_supports_prepared_level_1; end
    def ffi_supports_prepared_level_2; end
    def ffi_supports_set_output_dimension; end
    def ffi_supports_unary_union; end
    def marshal_wkb_generator; end
    def psych_wkt_generator; end
  end
end

class RGeo::Geos::ZMFactory
  include ::RGeo::Feature::Factory::Instance
  include ::RGeo::ImplHelper::Utils

  def initialize(opts = T.unsafe(nil)); end

  def ==(rhs); end
  def buffer_resolution; end
  def collection(elems); end
  def coord_sys; end
  def create_feature(klass, zgeometry, mgeometry); end
  def encode_with(coder); end
  def eql?(rhs); end
  def hash; end
  def init_with(coder); end
  def lenient_multi_polygon_assertions?; end
  def line(start, stop); end
  def line_string(points); end
  def linear_ring(points); end
  def m_factory; end
  def marshal_dump; end
  def marshal_load(data); end
  def marshal_wkb_generator; end
  def marshal_wkb_parser; end
  def multi_line_string(elems); end
  def multi_point(elems); end
  def multi_polygon(elems); end
  def override_cast(original, ntype, flags); end
  def parse_wkb(str); end
  def parse_wkt(str); end
  def point(x, y, z = T.unsafe(nil), m = T.unsafe(nil)); end
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end
  def proj4; end
  def property(name); end
  def psych_wkt_generator; end
  def psych_wkt_parser; end
  def srid; end
  def z_factory; end

  class << self
    def create(opts = T.unsafe(nil)); end
  end
end

RGeo::Geos::ZMFactory::TYPE_KLASSES = T.let(T.unsafe(nil), Hash)

class RGeo::Geos::ZMGeometryCollectionImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::ZMGeometryCollectionMethods
end

module RGeo::Geos::ZMGeometryCollectionMethods
  include ::Enumerable

  def [](n); end
  def each; end
  def geometry_n(n); end
  def num_geometries; end
  def size; end
end

class RGeo::Geos::ZMGeometryImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
end

module RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Feature::Instance

  def initialize(factory, zgeometry, mgeometry); end

  def *(rhs); end
  def +(rhs); end
  def -(rhs); end
  def ==(rhs); end
  def as_binary; end
  def as_text; end
  def boundary; end
  def buffer(distance_); end
  def contains?(rhs); end
  def convex_hull; end
  def crosses?(rhs); end
  def difference(rhs); end
  def dimension; end
  def disjoint?(rhs); end
  def distance(rhs); end
  def encode_with(coder); end
  def envelope; end
  def eql?(rhs); end
  def equals?(rhs); end
  def factory; end
  def geometry_type; end
  def hash; end
  def init_with(coder); end
  def inspect; end
  def intersection(rhs); end
  def intersects?(rhs); end
  def is_empty?; end
  def is_simple?; end
  def m_geometry; end
  def marshal_dump; end
  def marshal_load(data); end
  def overlaps?(rhs); end
  def relate(rhs, pattern); end
  def relate?(rhs, pattern); end
  def rep_equals?(rhs); end
  def srid; end
  def sym_difference(rhs); end
  def to_s; end
  def touches?(rhs); end
  def union(rhs); end
  def within?(rhs); end
  def z_geometry; end

  private

  def copy_state_from(obj); end
end

class RGeo::Geos::ZMLineImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMLineStringMethods
end

class RGeo::Geos::ZMLineStringImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMLineStringMethods
end

module RGeo::Geos::ZMLineStringMethods
  def coordinates; end
  def end_point; end
  def is_closed?; end
  def is_ring?; end
  def length; end
  def num_points; end
  def point_n(n); end
  def points; end
  def start_point; end
end

class RGeo::Geos::ZMLinearRingImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMLineStringMethods
end

class RGeo::Geos::ZMMultiLineStringImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::ZMGeometryCollectionMethods
  include ::RGeo::Geos::ZMMultiLineStringMethods
end

module RGeo::Geos::ZMMultiLineStringMethods
  def coordinates; end
  def is_closed?; end
  def length; end
end

class RGeo::Geos::ZMMultiPointImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::ZMGeometryCollectionMethods
end

class RGeo::Geos::ZMMultiPolygonImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::ZMGeometryCollectionMethods
  include ::RGeo::Geos::ZMMultiPolygonMethods
end

module RGeo::Geos::ZMMultiPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def point_on_surface; end
end

class RGeo::Geos::ZMPointImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMPointMethods
end

module RGeo::Geos::ZMPointMethods
  def coordinates; end
  def m; end
  def x; end
  def y; end
  def z; end
end

class RGeo::Geos::ZMPolygonImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMPolygonMethods
end

module RGeo::Geos::ZMPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def exterior_ring; end
  def interior_ring_n(n); end
  def interior_rings; end
  def num_interior_rings; end
  def point_on_surface; end
end

module RGeo::ImplHelper; end

module RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::Enumerable

  def initialize(factory, elements); end

  def [](n); end
  def dimension; end
  def each(&block); end
  def elements; end
  def geometries; end
  def geometry_n(n); end
  def geometry_type; end
  def hash; end
  def is_empty?; end
  def num_geometries; end
  def rep_equals?(rhs); end

  private

  def copy_state_from(obj); end
end

module RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::Feature::Instance

  def as_binary; end
  def as_text; end
  def encode_with(coder); end
  def factory; end
  def factory=(_arg0); end
  def init_with(coder); end
  def inspect; end
  def marshal_dump; end
  def marshal_load(data); end
  def to_s; end

  private

  def copy_state_from(obj); end
  def validate_geometry; end
end

module RGeo::ImplHelper::BasicLineMethods
  def initialize(factory, start, stop); end

  def coordinates; end
  def geometry_type; end

  private

  def validate_geometry; end
end

module RGeo::ImplHelper::BasicLineStringMethods
  def initialize(factory, points); end

  def boundary; end
  def contains?(rhs); end
  def coordinates; end
  def dimension; end
  def end_point; end
  def geometry_type; end
  def hash; end
  def is_closed?; end
  def is_empty?; end
  def is_ring?; end
  def num_points; end
  def point_n(n); end
  def points; end
  def rep_equals?(rhs); end
  def start_point; end

  private

  def between_coordinate?(coord, start_coord, end_coord); end
  def contains_point?(point); end
  def copy_state_from(obj); end
  def point_collinear?(a, b, c); end
  def point_intersect_segment?(point, start_point, end_point); end
  def validate_geometry; end
end

module RGeo::ImplHelper::BasicLinearRingMethods
  def ccw?; end
  def geometry_type; end

  private

  def validate_geometry; end
end

module RGeo::ImplHelper::BasicMultiLineStringMethods
  def initialize(factory, elements); end

  def boundary; end
  def contains?(rhs); end
  def coordinates; end
  def geometry_type; end
  def is_closed?; end
  def length; end

  private

  def add_boundary(hash, point); end
end

module RGeo::ImplHelper::BasicMultiPointMethods
  def initialize(factory, elements); end

  def boundary; end
  def coordinates; end
  def geometry_type; end
end

module RGeo::ImplHelper::BasicMultiPolygonMethods
  def initialize(factory, elements); end

  def area; end
  def boundary; end
  def contains?(rhs); end
  def coordinates; end
  def geometry_type; end
end

module RGeo::ImplHelper::BasicPointMethods
  def initialize(factory, x, y, *extra); end

  def boundary; end
  def convex_hull; end
  def coordinates; end
  def dimension; end
  def envelope; end
  def equals?(rhs); end
  def geometry_type; end
  def hash; end
  def is_empty?; end
  def is_simple?; end
  def m; end
  def rep_equals?(rhs); end
  def x; end
  def y; end
  def z; end

  private

  def copy_state_from(obj); end
end

module RGeo::ImplHelper::BasicPolygonMethods
  def initialize(factory, exterior_ring, interior_rings); end

  def boundary; end
  def contains?(rhs); end
  def coordinates; end
  def dimension; end
  def exterior_ring; end
  def geometry_type; end
  def hash; end
  def interior_ring_n(n); end
  def interior_rings; end
  def is_empty?; end
  def num_interior_rings; end
  def rep_equals?(rhs); end

  private

  def contains_point?(point); end
  def copy_state_from(obj); end
  def ring_encloses_point?(ring, point, on_border_return: T.unsafe(nil)); end
end

module RGeo::ImplHelper::Math; end
RGeo::ImplHelper::Math::DEGREES_PER_RADIAN = T.let(T.unsafe(nil), Float)
RGeo::ImplHelper::Math::RADIANS_PER_DEGREE = T.let(T.unsafe(nil), Float)

module RGeo::ImplHelper::Utils
  private

  def symbolize_hash(hash); end
end

RGeo::VERSION = T.let(T.unsafe(nil), String)
module RGeo::WKRep; end

class RGeo::WKRep::WKBGenerator
  def initialize(opts = T.unsafe(nil)); end

  def emit_ewkb_srid?; end
  def generate(obj); end
  def hex_format?; end
  def little_endian?; end
  def properties; end
  def type_format; end

  private

  def emit_byte(value); end
  def emit_doubles(array); end
  def emit_integer(value); end
  def emit_line_string_coords(obj); end
  def finish_emitter; end
  def generate_feature(obj, toplevel = T.unsafe(nil)); end
  def point_coords(obj, array = T.unsafe(nil)); end
  def start_emitter; end
end

RGeo::WKRep::WKBGenerator::TYPE_CODES = T.let(T.unsafe(nil), Hash)

class RGeo::WKRep::WKBParser
  def initialize(factory_generator = T.unsafe(nil), opts = T.unsafe(nil)); end

  def exact_factory; end
  def factory_generator; end
  def ignore_extra_bytes?; end
  def parse(data); end
  def parse_hex(data); end
  def properties; end
  def support_ewkb?; end
  def support_wkb12?; end

  private

  def bytes_remaining; end
  def get_byte; end
  def get_doubles(little_endian, count); end
  def get_integer(little_endian); end
  def parse_line_string(little_endian); end
  def parse_object(contained); end
  def start_scanner(data); end
end

class RGeo::WKRep::WKTGenerator
  def initialize(opts = T.unsafe(nil)); end

  def convert_case; end
  def emit_ewkt_srid?; end
  def generate(obj); end
  def properties; end
  def square_brackets?; end
  def tag_format; end
  def type_format; end

  private

  def generate_coords(obj); end
  def generate_feature(obj, toplevel = T.unsafe(nil)); end
  def generate_geometry_collection(obj); end
  def generate_line_string(obj); end
  def generate_multi_line_string(obj); end
  def generate_multi_point(obj); end
  def generate_multi_polygon(obj); end
  def generate_point(obj); end
  def generate_polygon(obj); end
end

class RGeo::WKRep::WKTParser
  def initialize(factory_generator = T.unsafe(nil), opts = T.unsafe(nil)); end

  def exact_factory; end
  def factory_generator; end
  def ignore_extra_tokens?; end
  def parse(str); end
  def properties; end
  def strict_wkt11?; end
  def support_ewkt?; end
  def support_wkt12?; end

  private

  def check_factory_support; end
  def clean_scanner; end
  def ensure_factory; end
  def expect_token_type(type); end
  def next_token; end
  def parse_coords; end
  def parse_geometry_collection; end
  def parse_line_string; end
  def parse_multi_line_string; end
  def parse_multi_point; end
  def parse_multi_polygon; end
  def parse_point(convert_empty = T.unsafe(nil)); end
  def parse_polygon; end
  def parse_type_tag; end
  def start_scanner(str); end
end
