# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/capistrano/all/capistrano.rbi
#
# capistrano-2.15.9

module Capistrano
  def self.configuration(*args); end
  def self.plugin(name, mod); end
  def self.remove_plugin(name); end
end
class Capistrano::Logger
  def close; end
  def debug(message, line_prefix = nil); end
  def device; end
  def device=(arg0); end
  def disable_formatters; end
  def disable_formatters=(arg0); end
  def format(message, color, style, nl = nil); end
  def important(message, line_prefix = nil); end
  def info(message, line_prefix = nil); end
  def initialize(options = nil); end
  def level; end
  def level=(arg0); end
  def log(level, message, line_prefix = nil); end
  def self.add_formatter(options); end
  def self.default_formatters; end
  def self.default_formatters=(defaults = nil); end
  def self.sorted_formatters; end
  def trace(message, line_prefix = nil); end
end
class Capistrano::Configuration
  def debug; end
  def debug=(arg0); end
  def defer; end
  def dry_run; end
  def dry_run=(arg0); end
  def initialize(*args); end
  def initialize_without_callbacks(*args); end
  def initialize_without_connections(*args); end
  def initialize_without_execution(*args); end
  def initialize_without_invocation(*args); end
  def initialize_without_loading(*args); end
  def initialize_without_namespaces(*args); end
  def initialize_without_roles(*args); end
  def initialize_without_variables(options = nil); end
  def invoke_task_directly(task); end
  def invoke_task_directly_without_callbacks(task); end
  def logger; end
  def logger=(arg0); end
  def method_missing(sym, *args, &block); end
  def method_missing_without_variables(*arg0); end
  def preserve_roles; end
  def preserve_roles=(arg0); end
  def respond_to?(sym, include_priv = nil); end
  def respond_to_without_variables?(*arg0); end
  extend Capistrano::Configuration::Actions::Invocation::ClassMethods
  extend Capistrano::Configuration::Loading::ClassMethods
  include Capistrano::Configuration::Actions::FileTransfer
  include Capistrano::Configuration::AliasTask
  include Capistrano::Configuration::Callbacks
end
module Capistrano::Configuration::AliasTask
  def alias_task(new_name, old_name); end
end
class Capistrano::Callback
  def applies_to?(task); end
  def except; end
  def initialize(source, options = nil); end
  def only; end
  def options; end
  def source; end
end
class Capistrano::ProcCallback < Capistrano::Callback
  def call; end
end
class Capistrano::TaskCallback < Capistrano::Callback
  def applies_to?(task); end
  def call; end
  def config; end
  def initialize(config, source, options = nil); end
end
module Capistrano::Configuration::Callbacks
  def after(task_name, *args, &block); end
  def before(task_name, *args, &block); end
  def callbacks; end
  def filter_deprecated_tasks(names); end
  def initialize_with_callbacks(*args); end
  def invoke_task_directly_with_callbacks(task); end
  def on(event, *args, &block); end
  def self.included(base); end
  def trigger(event, task = nil); end
end
class Capistrano::SSH
  def self.connect(server, options = nil); end
  def self.connection_strategy(server, options = nil, &block); end
end
module Capistrano::SSH::Server
  def self.apply_to(connection, server); end
  def xserver; end
  def xserver=(arg0); end
end
class Capistrano::Error < RuntimeError
end
class Capistrano::CaptureError < Capistrano::Error
end
class Capistrano::NoSuchTaskError < Capistrano::Error
end
class Capistrano::NoMatchingServersError < Capistrano::Error
end
class Capistrano::RemoteError < Capistrano::Error
  def hosts; end
  def hosts=(arg0); end
end
class Capistrano::ConnectionError < Capistrano::RemoteError
end
class Capistrano::TransferError < Capistrano::RemoteError
end
class Capistrano::CommandError < Capistrano::RemoteError
end
class Capistrano::LocalArgumentError < Capistrano::Error
end
module Capistrano::Configuration::Connections
  def connect!(options = nil); end
  def connection_factory; end
  def establish_connection_to(server, failures = nil); end
  def establish_connections_to(servers); end
  def execute_on_servers(options = nil); end
  def failed!(server); end
  def filter_servers(options = nil); end
  def has_failed?(server); end
  def initialize_with_connections(*args); end
  def safely_establish_connection_to(server, thread, failures = nil); end
  def self.included(base); end
  def sessions; end
  def teardown_connections_to(servers); end
end
class Capistrano::Configuration::Connections::DefaultConnectionFactory
  def connect_to(server); end
  def initialize(options); end
end
class Capistrano::Configuration::Connections::GatewayConnectionFactory
  def add_gateway(gateway); end
  def connect_to(server); end
  def gateway_for(server); end
  def initialize(gateway, options); end
end
module Capistrano::Configuration::Execution
  def current_task; end
  def execute_task(task); end
  def find_and_execute_task(path, hooks = nil); end
  def initialize_with_execution(*args); end
  def invoke_task_directly(task); end
  def on_rollback(&block); end
  def pop_task_call_frame; end
  def push_task_call_frame(task); end
  def rollback!; end
  def rollback_requests; end
  def rollback_requests=(rollback_requests); end
  def self.included(base); end
  def task_call_frames; end
  def transaction; end
  def transaction?; end
end
class Capistrano::Configuration::Execution::TaskCallFrame < Struct
  def rollback; end
  def rollback=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def task; end
  def task=(_); end
end
module Capistrano::Configuration::Loading
  def file_in_load_path?(file); end
  def find_file_in_load_path(file); end
  def initialize_with_loading(*args); end
  def load(*args, &block); end
  def load_from_file(file, name = nil); end
  def load_paths; end
  def remember_load(options); end
  def require(*args); end
  def self.included(base); end
end
module Capistrano::Configuration::Loading::ClassMethods
  def current_feature; end
  def current_feature=(feature); end
  def instance(require_config = nil); end
  def instance=(config); end
  def recipes_per_feature; end
end
module Capistrano::Configuration::LogFormatters
  def default_log_formatters(formatters); end
  def disable_log_formatters; end
  def log_formatter(options); end
end
class Capistrano::ServerDefinition
  def <=>(server); end
  def ==(server); end
  def eql?(server); end
  def hash; end
  def host; end
  def initialize(string, options = nil); end
  def options; end
  def port; end
  def self.default_user; end
  def to_s; end
  def user; end
  include Comparable
end
class Capistrano::TaskDefinition
  def body; end
  def brief_description(max_length = nil); end
  def continue_on_error?; end
  def desc; end
  def description(rebuild = nil); end
  def fully_qualified_name; end
  def initialize(name, namespace, options = nil, &block); end
  def max_hosts; end
  def name; end
  def name=(value); end
  def namespace; end
  def on_error; end
  def options; end
end
module Capistrano::Configuration::Namespaces
  def all_methods; end
  def default_task; end
  def define_task(task); end
  def desc(text); end
  def find_task(name); end
  def fully_qualified_name; end
  def initialize_with_namespaces(*args); end
  def name; end
  def namespace(name, &block); end
  def namespaces; end
  def next_description(reset = nil); end
  def parent; end
  def search_task(name); end
  def self.included(base); end
  def task(name, options = nil, &block); end
  def task_list(all = nil); end
  def tasks; end
  def top; end
end
class Capistrano::Configuration::Namespaces::Namespace
  def initialize(*args); end
  def initialize_without_namespaces(name, parent); end
  def method_missing(sym, *args, &block); end
  def respond_to?(sym, include_priv = nil); end
  def role(*args); end
  include Capistrano::Configuration::AliasTask
  include Capistrano::Configuration::Namespaces
end
module Kernel
  def self.method_added(name); end
  def self.method_added_without_capistrano(arg0); end
end
class Capistrano::Role
  def <<(*list); end
  def clear; end
  def dynamic_servers; end
  def each(&block); end
  def empty?; end
  def include?(server); end
  def initialize(*list); end
  def push(*list); end
  def self.wrap_list(*list); end
  def self.wrap_server(item, options); end
  def servers; end
  def to_ary; end
  include Enumerable
end
class Capistrano::Role::DynamicServerList
  def initialize(block, options); end
  def reset!; end
  def to_ary; end
end
module Capistrano::Configuration::Roles
  def initialize_with_roles(*args); end
  def role(which, *args, &block); end
  def role_names_for_host(host); end
  def roles; end
  def self.included(base); end
  def server(host, *roles); end
end
module Capistrano::Configuration::Servers
  def build_list(list); end
  def filter_server_list(servers); end
  def find_servers(options = nil); end
  def find_servers_for_task(task, options = nil); end
  def role_list_from(roles); end
  def server_list_from(hosts); end
end
module Capistrano::Configuration::Variables
  def [](variable); end
  def []=(variable, *args, &block); end
  def exists?(variable); end
  def fetch(variable, *args); end
  def initialize_with_variables(*args); end
  def method_missing_with_variables(sym, *args, &block); end
  def protect(variable); end
  def reset!(variable); end
  def respond_to_with_variables?(sym, include_priv = nil); end
  def self.included(base); end
  def set(variable, *args, &block); end
  def unset(variable); end
  def variables; end
end
module Capistrano::Processable
  def ensure_each_session; end
  def process_iteration(wait = nil, &block); end
end
module Capistrano::Processable::SessionAssociation
  def self.on(exception, session); end
  def session; end
  def session=(arg0); end
end
class Capistrano::Transfer
  def active?; end
  def callback; end
  def direction; end
  def from; end
  def handle_error(error); end
  def initialize(direction, from, to, sessions, options = nil, &block); end
  def logger; end
  def normalize(argument, session); end
  def operation; end
  def options; end
  def prepare_scp_transfer(from, to, session); end
  def prepare_sftp_transfer(from, to, session); end
  def prepare_transfers; end
  def process!; end
  def sanitized_from; end
  def sanitized_to; end
  def self.process(direction, from, to, sessions, options = nil, &block); end
  def session_map; end
  def sessions; end
  def to; end
  def transfers; end
  def transport; end
  include Capistrano::Processable
end
class Capistrano::Transfer::SFTPTransferWrapper
  def [](key); end
  def []=(key, value); end
  def abort!; end
  def active?; end
  def initialize(session, &callback); end
  def operation; end
end
module Capistrano::Configuration::Actions
end
module Capistrano::Configuration::Actions::FileTransfer
  def download(from, to, options = nil, &block); end
  def get(remote_path, path, options = nil, &block); end
  def put(data, path, options = nil); end
  def transfer(direction, from, to, options = nil, &block); end
  def upload(from, to, options = nil, &block); end
end
module Capistrano::Configuration::Actions::Inspect
  def capture(command, options = nil); end
  def stream(command, options = nil); end
end
class Capistrano::Command
  def environment; end
  def initialize(tree, sessions, options = nil, &block); end
  def logger; end
  def open_channels; end
  def options; end
  def process!; end
  def replace_placeholders(command, channel); end
  def request_pty_if_necessary(channel); end
  def self.process(tree, sessions, options = nil); end
  def sessions; end
  def stop!; end
  def tree; end
  include Capistrano::Processable
end
class Capistrano::Command::Tree
  def branches; end
  def branches_for(server); end
  def configuration; end
  def each; end
  def else(command, &block); end
  def fallback; end
  def initialize(config); end
  def when(condition, command, options = nil, &block); end
  include Enumerable
end
class Capistrano::Command::Tree::Branch
  def callback; end
  def callback=(arg0); end
  def command; end
  def command=(arg0); end
  def condition; end
  def condition=(arg0); end
  def initialize(command, options, callback); end
  def last?; end
  def match(server); end
  def options; end
  def skip!; end
  def skip?; end
  def to_s(parallel = nil); end
end
class Capistrano::Command::Tree::ConditionBranch < Capistrano::Command::Tree::Branch
  def configuration; end
  def configuration=(arg0); end
  def initialize(configuration, condition, command, options, callback); end
  def match(server); end
end
class Capistrano::Command::Tree::ConditionBranch::Evaluator
  def condition; end
  def configuration; end
  def in?(role); end
  def initialize(config, condition, server); end
  def method_missing(sym, *args, &block); end
  def result; end
  def server; end
end
class Capistrano::Command::Tree::ElseBranch < Capistrano::Command::Tree::Branch
  def initialize(command, options, callback); end
end
module Capistrano::Configuration::Actions::Invocation
  def add_default_command_options(options); end
  def branches_for_servers(tree, servers); end
  def continue_execution(tree); end
  def continue_execution_for_branch(branch); end
  def initialize_with_invocation(*args); end
  def invoke_command(cmd, options = nil, &block); end
  def parallel(options = nil); end
  def run(cmd, options = nil, &block); end
  def run_tree(tree, options = nil); end
  def self.included(base); end
  def sudo(*parameters, &block); end
  def sudo_behavior_callback(fallback); end
  def sudo_prompt; end
end
module Capistrano::Configuration::Actions::Invocation::ClassMethods
  def default_io_proc; end
  def default_io_proc=(arg0); end
end
class Capistrano::ExtensionProxy
  def initialize(config, mod); end
  def method_missing(sym, *args, &block); end
end
class String
  def compact; end
end
class Capistrano::Version
  def self.to_s; end
end
