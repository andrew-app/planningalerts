# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack-mini-profiler` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

class Mysql2::Client
  def initialize(opts = T.unsafe(nil)); end

  def abandon_results!; end
  def affected_rows; end
  def async_result; end
  def automatic_close=(_arg0); end
  def automatic_close?; end
  def close; end
  def closed?; end
  def encoding; end
  def escape(_arg0); end
  def info; end
  def last_id; end
  def more_results?; end
  def next_result; end
  def parse_connect_attrs(conn_attrs); end
  def parse_flags_array(flags, initial = T.unsafe(nil)); end
  def parse_ssl_mode(mode); end
  def ping; end
  def prepare(_arg0); end
  def query(*args, &blk); end
  def query_info; end
  def query_info_string; end
  def query_options; end
  def query_without_profiling(sql, options = T.unsafe(nil)); end
  def read_timeout; end
  def reconnect=(_arg0); end
  def select_db(_arg0); end
  def server_info; end
  def set_server_option(_arg0); end
  def socket; end
  def ssl_cipher; end
  def store_result; end
  def thread_id; end
  def warning_count; end

  private

  def _query(_arg0, _arg1); end
  def charset_name=(_arg0); end
  def connect(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7); end
  def connect_timeout=(_arg0); end
  def default_auth=(_arg0); end
  def default_file=(_arg0); end
  def default_group=(_arg0); end
  def enable_cleartext_plugin=(_arg0); end
  def init_command=(_arg0); end
  def initialize_ext; end
  def local_infile=(_arg0); end
  def read_timeout=(_arg0); end
  def secure_auth=(_arg0); end
  def ssl_mode=(_arg0); end
  def ssl_set(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def write_timeout=(_arg0); end

  class << self
    def default_query_options; end
    def escape(_arg0); end
    def info; end

    private

    def local_offset; end
  end
end

Mysql2::Client::ALL_FLAGS = T.let(T.unsafe(nil), Integer)

Mysql2::Client::BASIC_FLAGS = T.let(T.unsafe(nil), Integer)

Mysql2::Client::COMPRESS = T.let(T.unsafe(nil), Integer)

Mysql2::Client::CONNECT_ATTRS = T.let(T.unsafe(nil), Integer)

Mysql2::Client::CONNECT_WITH_DB = T.let(T.unsafe(nil), Integer)

Mysql2::Client::FOUND_ROWS = T.let(T.unsafe(nil), Integer)

Mysql2::Client::IGNORE_SIGPIPE = T.let(T.unsafe(nil), Integer)

Mysql2::Client::IGNORE_SPACE = T.let(T.unsafe(nil), Integer)

Mysql2::Client::INTERACTIVE = T.let(T.unsafe(nil), Integer)

Mysql2::Client::LOCAL_FILES = T.let(T.unsafe(nil), Integer)

Mysql2::Client::LONG_FLAG = T.let(T.unsafe(nil), Integer)

Mysql2::Client::LONG_PASSWORD = T.let(T.unsafe(nil), Integer)

Mysql2::Client::MULTI_STATEMENTS = T.let(T.unsafe(nil), Integer)

Mysql2::Client::NO_SCHEMA = T.let(T.unsafe(nil), Integer)

Mysql2::Client::ODBC = T.let(T.unsafe(nil), Integer)

Mysql2::Client::OPTION_MULTI_STATEMENTS_OFF = T.let(T.unsafe(nil), Integer)

Mysql2::Client::OPTION_MULTI_STATEMENTS_ON = T.let(T.unsafe(nil), Integer)

Mysql2::Client::PROTOCOL_41 = T.let(T.unsafe(nil), Integer)

Mysql2::Client::PS_MULTI_RESULTS = T.let(T.unsafe(nil), Integer)

Mysql2::Client::REMEMBER_OPTIONS = T.let(T.unsafe(nil), Integer)

Mysql2::Client::RESERVED = T.let(T.unsafe(nil), Integer)

Mysql2::Client::SECURE_CONNECTION = T.let(T.unsafe(nil), Integer)

Mysql2::Client::SSL = T.let(T.unsafe(nil), Integer)

Mysql2::Client::SSL_MODE_DISABLED = T.let(T.unsafe(nil), Integer)

Mysql2::Client::SSL_MODE_PREFERRED = T.let(T.unsafe(nil), Integer)

Mysql2::Client::SSL_MODE_REQUIRED = T.let(T.unsafe(nil), Integer)

Mysql2::Client::SSL_MODE_VERIFY_CA = T.let(T.unsafe(nil), Integer)

Mysql2::Client::SSL_MODE_VERIFY_IDENTITY = T.let(T.unsafe(nil), Integer)

Mysql2::Client::SSL_VERIFY_SERVER_CERT = T.let(T.unsafe(nil), Integer)

Mysql2::Client::TRANSACTIONS = T.let(T.unsafe(nil), Integer)

class Mysql2::Result
  include(::Enumerable)

  def count; end
  def each(*args, &blk); end
  def each_without_profiling(*_arg0); end
  def fields; end
  def free; end
  def server_flags; end
  def size; end
end

module Rack
  class << self
    def release; end
    def version; end
  end
end

Rack::ADAPTERS = T.let(T.unsafe(nil), Array)

Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)

Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)

Rack::DELETE = T.let(T.unsafe(nil), String)

Rack::ETAG = T.let(T.unsafe(nil), String)

Rack::EXPIRES = T.let(T.unsafe(nil), String)

Rack::File = Rack::Files

Rack::GET = T.let(T.unsafe(nil), String)

Rack::HEAD = T.let(T.unsafe(nil), String)

Rack::HTTPS = T.let(T.unsafe(nil), String)

Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)

Rack::HTTP_HOST = T.let(T.unsafe(nil), String)

Rack::HTTP_PORT = T.let(T.unsafe(nil), String)

Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)

Rack::LINK = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler
  extend(::Rack::MiniProfiler::ProfilingMethods)

  def initialize(app, config = T.unsafe(nil)); end

  def advanced_debugging_enabled?; end
  def analyze_memory; end
  def cache_control_value; end
  def call(env); end
  def cancel_auto_inject(env); end
  def config; end
  def current; end
  def current=(c); end
  def dump_env(env); end
  def dump_exceptions(exceptions); end
  def flamegraph(graph, path); end
  def generate_html(page_struct, env, result_json = T.unsafe(nil)); end
  def get_profile_script(env); end
  def help(client_settings, env); end
  def ids(env); end
  def ids_comma_separated(env); end
  def inject(fragment, script); end
  def inject_profiler(env, status, headers, body); end
  def make_link(postfix, env); end
  def serve_html(env); end
  def serve_results(env); end
  def text_result(body); end
  def tool_disabled_message(client_settings); end
  def trim_strings(strings, max_size); end
  def user(env); end

  private

  def handle_snapshots_request(env); end
  def rails_route_from_path(path, method); end
  def serve_flamegraph(env); end
  def take_snapshot(env, start); end
  def take_snapshot?(path); end
  def url_for_snapshot(id); end
  def url_for_snapshots_group(group_name); end

  class << self
    def add_snapshot_custom_field(key, value); end
    def advanced_tools_message; end
    def authorize_request; end
    def binds_to_params(binds); end
    def config; end
    def create_current(env = T.unsafe(nil), options = T.unsafe(nil)); end
    def current; end
    def current=(c); end
    def deauthorize_request; end
    def discard_results; end
    def generate_id; end
    def get_snapshot_custom_fields; end
    def patch_rails?; end
    def redact_sql_queries?; end
    def request_authorized?; end
    def reset_config; end
    def resources_root; end
    def share_template; end
    def snapshots_transporter?; end
    def subscribe_sql_active_record; end
    def subscribe_sql_active_record=(_arg0); end
  end
end

Rack::MiniProfiler::ASSET_VERSION = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::AbstractStore
  def allowed_tokens; end
  def diagnostics(user); end
  def fetch_snapshots(batch_size: T.unsafe(nil), &blk); end
  def find_snapshots_group(group_name); end
  def get_unviewed_ids(user); end
  def load(id); end
  def load_snapshot(id); end
  def push_snapshot(page_struct, config); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end
  def should_take_snapshot?(period); end
  def snapshot_groups_overview; end

  private

  def default_snapshot_grouping(snapshot); end
  def rails_route_from_path(path, method); end
end

Rack::MiniProfiler::AbstractStore::MAX_TOKEN_AGE = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::ClientSettings
  def initialize(env, store, start); end

  def backtrace_default?; end
  def backtrace_full?; end
  def backtrace_level; end
  def backtrace_level=(_arg0); end
  def backtrace_none?; end
  def disable_profiling; end
  def disable_profiling=(_arg0); end
  def disable_profiling?; end
  def discard_cookie!(headers); end
  def handle_cookie(result); end
  def has_valid_cookie?; end
  def write!(headers); end
end

Rack::MiniProfiler::ClientSettings::BACKTRACE_FULL = T.let(T.unsafe(nil), Integer)

Rack::MiniProfiler::ClientSettings::BACKTRACE_NONE = T.let(T.unsafe(nil), Integer)

Rack::MiniProfiler::ClientSettings::COOKIE_NAME = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::Config
  def assets_url; end
  def assets_url=(lmbda); end
  def authorization_mode; end
  def authorization_mode=(mode); end
  def auto_inject; end
  def auto_inject=(_arg0); end
  def backtrace_ignores; end
  def backtrace_ignores=(_arg0); end
  def backtrace_includes; end
  def backtrace_includes=(_arg0); end
  def backtrace_remove; end
  def backtrace_remove=(_arg0); end
  def backtrace_threshold_ms; end
  def backtrace_threshold_ms=(_arg0); end
  def base_url_path; end
  def base_url_path=(_arg0); end
  def collapse_results; end
  def collapse_results=(_arg0); end
  def content_security_policy_nonce; end
  def content_security_policy_nonce=(_arg0); end
  def disable_caching; end
  def disable_caching=(_arg0); end
  def enable_advanced_debugging_tools; end
  def enable_advanced_debugging_tools=(_arg0); end
  def enable_hotwire_turbo_drive_support; end
  def enable_hotwire_turbo_drive_support=(_arg0); end
  def enabled; end
  def enabled=(_arg0); end
  def flamegraph_mode; end
  def flamegraph_mode=(_arg0); end
  def flamegraph_sample_rate; end
  def flamegraph_sample_rate=(_arg0); end
  def horizontal_position; end
  def html_container; end
  def html_container=(_arg0); end
  def logger; end
  def logger=(_arg0); end
  def max_sql_param_length; end
  def max_sql_param_length=(_arg0); end
  def max_traces_to_show; end
  def max_traces_to_show=(_arg0); end
  def merge!(config); end
  def position; end
  def position=(_arg0); end
  def pre_authorize_cb; end
  def pre_authorize_cb=(_arg0); end
  def show_children; end
  def show_children=(_arg0); end
  def show_controls; end
  def show_controls=(_arg0); end
  def show_total_sql_count; end
  def show_total_sql_count=(_arg0); end
  def show_trivial; end
  def show_trivial=(_arg0); end
  def skip_paths; end
  def skip_paths=(_arg0); end
  def skip_schema_queries; end
  def skip_schema_queries=(_arg0); end
  def skip_sql_param_names; end
  def skip_sql_param_names=(_arg0); end
  def snapshot_every_n_requests; end
  def snapshot_every_n_requests=(_arg0); end
  def snapshot_hidden_custom_fields; end
  def snapshot_hidden_custom_fields=(_arg0); end
  def snapshots_limit; end
  def snapshots_limit=(_arg0); end
  def snapshots_redact_sql_queries; end
  def snapshots_redact_sql_queries=(_arg0); end
  def snapshots_transport_auth_key; end
  def snapshots_transport_auth_key=(_arg0); end
  def snapshots_transport_destination_url; end
  def snapshots_transport_destination_url=(_arg0); end
  def snapshots_transport_gzip_requests; end
  def snapshots_transport_gzip_requests=(_arg0); end
  def start_hidden; end
  def start_hidden=(_arg0); end
  def storage; end
  def storage=(_arg0); end
  def storage_failure; end
  def storage_failure=(_arg0); end
  def storage_instance; end
  def storage_instance=(_arg0); end
  def storage_options; end
  def storage_options=(_arg0); end
  def suppress_encoding; end
  def suppress_encoding=(_arg0); end
  def toggle_shortcut; end
  def toggle_shortcut=(_arg0); end
  def use_existing_jquery; end
  def use_existing_jquery=(_arg0); end
  def user_provider; end
  def user_provider=(_arg0); end
  def vertical_position; end

  class << self
    def attr_accessor(*vars); end
    def attributes; end
    def default; end
  end
end

class Rack::MiniProfiler::Context
  def initialize(opts = T.unsafe(nil)); end

  def current_timer; end
  def current_timer=(_arg0); end
  def discard; end
  def discard=(_arg0); end
  def full_backtrace; end
  def full_backtrace=(_arg0); end
  def inject_js; end
  def inject_js=(_arg0); end
  def measure; end
  def measure=(_arg0); end
  def mpt_init; end
  def mpt_init=(_arg0); end
  def page_struct; end
  def page_struct=(_arg0); end
  def skip_backtrace; end
  def skip_backtrace=(_arg0); end
end

class Rack::MiniProfiler::FileStore < ::Rack::MiniProfiler::AbstractStore
  def initialize(args = T.unsafe(nil)); end

  def allowed_tokens; end
  def cleanup_cache; end
  def flush_tokens; end
  def get_unviewed_ids(user); end
  def load(id); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end
end

class Rack::MiniProfiler::FileStore::CacheCleanupThread < ::Thread
end

Rack::MiniProfiler::FileStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::FileStore::FileCache
  def initialize(path, prefix); end

  def [](key); end
  def []=(key, val); end

  private

  def path(key); end
end

class Rack::MiniProfiler::GCProfiler
  def initialize; end

  def analyze_growth(ids_before, ids_after); end
  def analyze_initial_state(ids_before); end
  def analyze_strings(ids_before, ids_after); end
  def diff_object_stats(before, after); end
  def object_space_stats; end
  def profile_gc(app, env); end
end

class Rack::MiniProfiler::MemcacheStore < ::Rack::MiniProfiler::AbstractStore
  def initialize(args = T.unsafe(nil)); end

  def allowed_tokens; end
  def flush_tokens; end
  def get_unviewed_ids(user); end
  def load(id); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end
end

Rack::MiniProfiler::MemcacheStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

Rack::MiniProfiler::MemcacheStore::MAX_RETRIES = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::MemoryStore < ::Rack::MiniProfiler::AbstractStore
  def initialize(args = T.unsafe(nil)); end

  def allowed_tokens; end
  def cleanup_cache; end
  def fetch_snapshots(batch_size: T.unsafe(nil), &blk); end
  def get_unviewed_ids(user); end
  def initialize_cleanup_thread(args = T.unsafe(nil)); end
  def initialize_locks; end
  def load(id); end
  def load_snapshot(id); end
  def push_snapshot(page_struct, config); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end
  def should_take_snapshot?(period); end

  private

  def wipe_snapshots_data; end
end

Rack::MiniProfiler::MemoryStore::CLEANUP_CYCLE = T.let(T.unsafe(nil), Integer)

Rack::MiniProfiler::MemoryStore::CLEANUP_INTERVAL = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::MemoryStore::CacheCleanupThread < ::Thread
  def initialize(interval, cycle, store); end

  def cleanup; end
  def cycle_count; end
  def increment_cycle; end
  def should_cleanup?; end
  def sleepy_run; end
end

Rack::MiniProfiler::MemoryStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

module Rack::MiniProfiler::ProfilingMethods
  def counter(type, duration_ms = T.unsafe(nil)); end
  def counter_method(klass, method, &blk); end
  def finish_step(obj); end
  def profile_method(klass, method, type = T.unsafe(nil), &blk); end
  def profile_singleton_method(klass, method, type = T.unsafe(nil), &blk); end
  def record_sql(query, elapsed_ms, params = T.unsafe(nil)); end
  def start_step(name); end
  def step(name, opts = T.unsafe(nil)); end
  def uncounter_method(klass, method); end
  def unprofile_method(klass, method); end
  def unprofile_singleton_method(klass, method); end

  private

  def clean_method_name(method); end
end

class Rack::MiniProfiler::RedisStore < ::Rack::MiniProfiler::AbstractStore
  def initialize(args = T.unsafe(nil)); end

  def allowed_tokens; end
  def diagnostics(user); end
  def fetch_snapshots(batch_size: T.unsafe(nil), &blk); end
  def flush_tokens; end
  def get_unviewed_ids(user); end
  def load(id); end
  def load_snapshot(id); end
  def prefix; end
  def push_snapshot(page_struct, config); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end
  def should_take_snapshot?(period); end
  def simulate_expire; end

  private

  def cached_redis_eval(script, script_sha, reraise: T.unsafe(nil), argv: T.unsafe(nil), keys: T.unsafe(nil)); end
  def prefixed_id(id); end
  def redis; end
  def snapshot_counter_key; end
  def snapshot_hash_key; end
  def snapshot_zset_key; end
  def user_key(user); end
  def wipe_snapshots_data; end
end

Rack::MiniProfiler::RedisStore::COUNTER_LUA = T.let(T.unsafe(nil), String)

Rack::MiniProfiler::RedisStore::COUNTER_LUA_SHA = T.let(T.unsafe(nil), String)

Rack::MiniProfiler::RedisStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

Rack::MiniProfiler::SOURCE_CODE_URI = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::SnapshotsTransporter
  def initialize(config); end

  def buffer; end
  def flush_buffer; end
  def gzip_requests; end
  def gzip_requests=(_arg0); end
  def max_buffer_size; end
  def max_buffer_size=(_arg0); end
  def requests_interval; end
  def ship(snapshot); end

  private

  def backoff_delay; end
  def start_thread; end

  class << self
    def failed_http_requests_count; end
    def successful_http_requests_count; end
    def transport(snapshot); end
    def transported_snapshots_count; end
  end
end

module Rack::MiniProfiler::TimerStruct
end

class Rack::MiniProfiler::TimerStruct::Base
  def initialize(attrs = T.unsafe(nil)); end

  def [](name); end
  def []=(name, val); end
  def as_json(options = T.unsafe(nil)); end
  def attributes; end
  def to_json(*a); end
end

class Rack::MiniProfiler::TimerStruct::Client < ::Rack::MiniProfiler::TimerStruct::Base
  def initialize(env = T.unsafe(nil)); end

  def redirect_count; end
  def timings; end

  class << self
    def init_from_form_data(env, page_struct); end
    def init_instrumentation; end
    def instrument(name, orig); end
  end
end

class Rack::MiniProfiler::TimerStruct::Custom < ::Rack::MiniProfiler::TimerStruct::Base
  def initialize(type, duration_ms, page, parent); end

  def parent; end
  def parent=(_arg0); end
end

class Rack::MiniProfiler::TimerStruct::Page < ::Rack::MiniProfiler::TimerStruct::Base
  def initialize(env); end

  def as_json(options = T.unsafe(nil)); end
  def attributes; end
  def attributes_to_serialize; end
  def duration_ms; end
  def duration_ms_in_sql; end
  def extra_json; end
  def name; end
  def root; end
  def to_json(*a); end

  class << self
    def from_hash(hash); end

    private

    def symbolize_array(array); end
    def symbolize_hash(hash); end
  end
end

class Rack::MiniProfiler::TimerStruct::Request < ::Rack::MiniProfiler::TimerStruct::Base
  def initialize(name, page, parent); end

  def add_child(name); end
  def add_custom(type, elapsed_ms, page); end
  def add_sql(query, elapsed_ms, page, params = T.unsafe(nil), skip_backtrace = T.unsafe(nil), full_backtrace = T.unsafe(nil)); end
  def adjust_depth; end
  def children; end
  def children_duration; end
  def children_duration=(_arg0); end
  def custom_timings; end
  def depth; end
  def duration_ms; end
  def duration_ms_in_sql; end
  def move_child(child, destination); end
  def move_custom(type, custom, destination); end
  def move_sql(sql, destination); end
  def name; end
  def parent; end
  def parent=(_arg0); end
  def record_time(milliseconds = T.unsafe(nil)); end
  def sql_timings; end
  def start; end
  def start=(_arg0); end
  def start_ms; end

  class << self
    def createRoot(name, page); end
  end
end

class Rack::MiniProfiler::TimerStruct::Sql < ::Rack::MiniProfiler::TimerStruct::Base
  def initialize(query, duration_ms, page, parent, params = T.unsafe(nil), skip_backtrace = T.unsafe(nil), full_backtrace = T.unsafe(nil)); end

  def parent; end
  def parent=(_arg0); end
  def report_reader_duration(elapsed_ms); end
  def trim_binds(binds); end
end

Rack::MiniProfiler::VERSION = T.let(T.unsafe(nil), String)

module Rack::MiniProfilerRails
  extend(::Rack::MiniProfilerRailsMethods)

  class << self
    def create_engine; end
    def get_key(payload); end
    def initialize!(app); end
    def serves_static_assets?(app); end
    def shorten_identifier(identifier); end
    def subscribe(event, &blk); end
  end
end

class Rack::MiniProfilerRails::Railtie < ::Rails::Railtie
end

module Rack::MiniProfilerRailsMethods
  extend(::Rack::MiniProfilerRailsMethods)

  def get_webpacker_assets_path; end
  def render_notification_handler(name, finish, start, name_as_description: T.unsafe(nil)); end
  def should_measure?; end
  def should_move?(child, node); end
end

Rack::OPTIONS = T.let(T.unsafe(nil), String)

Rack::PATCH = T.let(T.unsafe(nil), String)

Rack::PATH_INFO = T.let(T.unsafe(nil), String)

Rack::POST = T.let(T.unsafe(nil), String)

Rack::PUT = T.let(T.unsafe(nil), String)

Rack::QUERY_STRING = T.let(T.unsafe(nil), String)

Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)

Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)

Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)

Rack::RACK_INPUT = T.let(T.unsafe(nil), String)

Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)

Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)

Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)

Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)

Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)

Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)

Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)

Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)

Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)

Rack::RACK_SESSION = T.let(T.unsafe(nil), String)

Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)

Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)

Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)

Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)

Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

Rack::RELEASE = T.let(T.unsafe(nil), String)

Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)

Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)

Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)

Rack::SERVER_NAME = T.let(T.unsafe(nil), String)

Rack::SERVER_PORT = T.let(T.unsafe(nil), String)

Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

Rack::SET_COOKIE = T.let(T.unsafe(nil), String)

Rack::TRACE = T.let(T.unsafe(nil), String)

Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

Rack::UNLINK = T.let(T.unsafe(nil), String)

Rack::VERSION = T.let(T.unsafe(nil), Array)

class SqlPatches
  class << self
    def all_patch_files; end
    def correct_version?(required_version, klass); end
    def elapsed_time(start_time); end
    def other_patches; end
    def patch(patch_files = T.unsafe(nil)); end
    def patch_rails?; end
    def record_sql(statement, parameters = T.unsafe(nil), &block); end
    def should_measure?; end
    def sql_patches; end
  end
end
